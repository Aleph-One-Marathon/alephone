;NETWORK_LISTENER.A

;	Copyright (C) 1991-2001 and beyond by Bungie Studios, Inc.
;	and the "Aleph One" developers.
 
;	This program is free software; you can redistribute it and/or modify
;	it under the terms of the GNU General Public License as published by
;	the Free Software Foundation; either version 2 of the License, or
;	(at your option) any later version.

;	This program is distributed in the hope that it will be useful,
;	but WITHOUT ANY WARRANTY; without even the implied warranty of
;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;	GNU General Public License for more details.

;	This license is contained in the file "GNU_GeneralPublicLicense.txt",
;	which is included with this source code; it is available online at
;	http://www.gnu.org/licenses/gpl.html


;Sunday, June 26, 1994 2:46:52 PM
;Thursday, June 30, 1994 11:10:19 PM
;  To get this to work right (due to forward referencing and poor manuals) I stuck everything
;  into one procedure. a bit ugly, but i couldn't get the forward referencing to work any other
;  way. i also got rid of the stuff to have multiple buffers, since socket listeners aren't
;  reentrant (ajr)

					machine	mc68020
					string	c

					include				'traps.a'
					include				'appletalk.a'
					include				'cseries.a'

buffer_in_use		equ		$8000

PacketBuffer		record	0
inUse				ds.w	1
protocolType		ds.b	1	;DDP protocol type
destinationNode		ds.b	1	;destination node (us or 255, presumably)
sourceAddress		ds.l	1	;source address in AddrBlock format
hops				ds.w	1	;hop count
datagramSize		ds.w	1	;length of datagram
datagramData		ds.b	ddpMaxData
					endr

;socket listener globals

TheSocketListener	proc	export

					bra.s	start	;branch over the globals to the initializer
					
; globals stuck in the procedure. we need to have them before we use them, yet we don't
; want to stick them at the beginning of the file because then they will be stuck at the
; beginning of the code resource that we create, which will be problematic for calling 
; these routines.
packet_buffer		dc.l	0	;packet buffer pointers
application_a5		dc.l	0	;caller’s a5
old_a5				dc.l	0	;saved a5 value on entry to the socket listener
packet_handler_proc	dc.l	0	;pointer to the function which handles packets

;					symbol	NetDDPSocketListenerHeader

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; socket listener initializer
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;ProcPtr NetInitializeSocketListener(void (*packet_handler_proc)(PacketBufferPtr packet), PacketBufferPtr packet_buffer);

					with	PacketBuffer

;remember the caller’s a5
start				lea		application_a5,a0
					move.l	a5,(a0)
					
;save the packet handler procedure, the packet buffer pointer and the number of valid
;packet buffers
					lea		packet_handler_proc,a0
					move.l	4(a7),(a0)
					lea		packet_buffer,a0
					move.l	8(a7),(a0)
					
;mark our buffer as not in use
					move.l	packet_buffer,a0
					clr.w	inUse(a0)

					lea		NetDDPSocketListener, a0 ;; return the address 
					move.l	a0, d0
					rts

;					symbol	NetDDPInitializeSocketListener
					endwith

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; the actual socket listener
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NetDDPSocketListener
					with	PacketBuffer

;get a pointer to our PacketBuffer
					move.l	packet_buffer,a3
					tas		inUse(a3)
					beq.s	read_packet

;if this _Debugger is ever triggered it means our socket listener was re-entered.
;  this is bad.
					_Debugger
;; so read the packet and exit without clearing the flag. may be temporary code
					move.l	d1,d3					;read the rest of the packet
					lea		datagramData(a3),a3		;into .datagramData
					jsr		2(a4)					;call ReadRest
					rts


read_packet
;read the rest of the packet into .datagramData field of PacketBuffer
;					move	SR, -(a7)
;					ori.w	#$0700, SR
					move.l	d1,d3					;read the rest of the packet
					lea		datagramData(a3),a3		;into .datagramData
					jsr		2(a4)					;call ReadRest
					bne.s	return_to_caller

_PACKET_BUFFER		equ		a0
_MPP_LOCALS			equ		a2
_HOP_COUNT			equ		d0
_DATAGRAM_LENGTH	equ		d1
_SOURCE_ADDRESS		equ		d2

					with	MPPGlobals
					with	ALAPHead
;get a pointer to our PacketBuffer
					move.l	packet_buffer, _PACKET_BUFFER

;get the hop count
					with	DDPLongHead
					move.w	toRHA+lapHdSz+ddpHopCnt(_MPP_LOCALS),_HOP_COUNT
					andi.w	#ddpHopsMask,_HOP_COUNT
					lsr.w	#2,_HOP_COUNT
					lsr.w	#8,_HOP_COUNT
					move.w	_HOP_COUNT,hops(_PACKET_BUFFER)

;get the datagram length (including header)
					move.w	toRHA+lapHdSz+ddpLength(_MPP_LOCALS),_DATAGRAM_LENGTH
					andi.w	#ddpLenMask,_DATAGRAM_LENGTH

;is this a long or a short header?
					move.b	toRHA+lapType(_MPP_LOCALS),d3
					cmpi.b	#shortDDP,d3
					beq.s	process_short_header

;------------------ process long header

process_long_header
;get protocol type and destination node
					move.b	toRHA+lapHdSz+ddpType(_MPP_LOCALS),protocolType(_PACKET_BUFFER)
					move.b	toRHA+lapHdSz+ddpDstNode(_MPP_LOCALS),destinationNode(_PACKET_BUFFER)

;build the source AddrBlock (sort of on the sly)
					move.l	toRHA+lapHdSz+ddpSrcNet(_MPP_LOCALS),_SOURCE_ADDRESS
					lsl.w	#8,_SOURCE_ADDRESS
					move.b	toRHA+lapHdSz+ddpSrcSkt(_MPP_LOCALS),_SOURCE_ADDRESS

;adjust _DATAGRAM_LENGTH to not include the header
					sub.w	#ddpType+1,_DATAGRAM_LENGTH

					bra.s	call_packet_handler
					endwith	; DDPLongHead

;------------------ process short header

process_short_header
					with	DDPShortHead
					move.b	toRHA+lapHdSz+ddpType(_MPP_LOCALS),protocolType(_PACKET_BUFFER)
					move.b	toRHA+lapDstAdr(_MPP_LOCALS),destinationNode(_PACKET_BUFFER)

;build the source AddrBlock (network is always zero for short headers)
					moveq	#0,_SOURCE_ADDRESS
					move.b	toRHA+lapSrcAdr(_MPP_LOCALS),_SOURCE_ADDRESS
					lsl.w	#8,_SOURCE_ADDRESS
					move.b	toRHA+lapHdSz+ddpSrcSkt(_MPP_LOCALS),_SOURCE_ADDRESS

;adjust _DATAGRAM_LENGTH to not include the header
					sub.w	#ddpType+1,_DATAGRAM_LENGTH
					endwith	; DDPShortHead
					endwith	; ALAPHead
					endwith	; MPPGlobals


call_packet_handler
;save _DATAGRAM_LENGTH and _SOURCE_ADDRESS
					move.l	_SOURCE_ADDRESS,sourceAddress(_PACKET_BUFFER)
					move.w	_DATAGRAM_LENGTH,datagramSize(_PACKET_BUFFER)

;save current a5, instantiate application a5
					lea		old_a5,a3
					move.l	a5,(a3)
					move.l	application_a5,a5

;push the address of our packet buffer onto the stack and call the packet handler
					move.l	_PACKET_BUFFER,-(sp)
					move.l	packet_handler_proc,a3
					jsr		(a3)
					addq	#4,sp

;restore old a5
					move.l	old_a5,a5

return_to_caller
;clear semaphore and return to caller
					move.l	packet_buffer, a3
					clr.w	inUse(a3)
;					move 	(a7)+, SR
					rts

;					symbol	NetDDPSocketListener

					endwith
					endproc

					end


<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="Lua.xsl"?>
<!DOCTYPE document [
	  <!ELEMENT document (section*,triggers,tables,types,section*)>
	  <!ATTLIST document title CDATA #REQUIRED>
	  
	  <!ELEMENT triggers (description?,(function*))>
	  <!ATTLIST triggers id ID #REQUIRED>
	  <!ELEMENT tables (description*,(table|accessor|enum|enum-accessor)*)>
	  <!ATTLIST tables id ID #REQUIRED>
	  <!ELEMENT types (description*)>
	  <!ATTLIST types id ID #REQUIRED>

	  <!ELEMENT section (description?,(section*))>
	  <!ATTLIST section name CDATA #REQUIRED>
	  <!ATTLIST section id ID #REQUIRED>
	  
	  <!ELEMENT table ((description?),(function|function-variable|subtable|subtable-accessor|variable)*)>
	  <!ATTLIST table name ID #REQUIRED>
	  <!ATTLIST table singleton (true|false) 'false'>

	  <!ELEMENT subtable ((alias*),(description?),(length?),(index?),(call?),(function|subtable|variable|note)*)>
	  <!ATTLIST subtable name CDATA #REQUIRED>
	  <!ATTLIST subtable classname ID #REQUIRED>

	  <!ELEMENT subtable-accessor ((alias?),(description?),(function|subtable|variable)*)>
	  <!ATTLIST subtable-accessor name CDATA #REQUIRED>
	  <!ATTLIST subtable-accessor classname ID #REQUIRED>
	  <!ATTLIST subtable-accessor index CDATA #REQUIRED>

	  <!ELEMENT description ANY>
	  <!ELEMENT br EMPTY>
	  <!ELEMENT p ANY>
	  <!ELEMENT pre ANY>

	  <!ELEMENT function ((description?),(argument*),(return*),(note*))>
	  <!ATTLIST function name CDATA #REQUIRED>
	  <!ATTLIST function access (local-player|all) 'all'>
	  <!ATTLIST function return (single|variant) 'single'>

	  <!ELEMENT function-variable ((description?),(argument),(type))>
	  <!ATTLIST function-variable name CDATA #REQUIRED>
	  <!ATTLIST function-variable classname CDATA #IMPLIED>

	  <!ELEMENT argument (description?,type)>
	  <!ATTLIST argument name CDATA #REQUIRED>
	  <!ATTLIST argument required (true|false) 'true'>

	  <!ELEMENT return (type)>

	  <!ELEMENT variable ((alias*), (description?),(type),(note*))>
	  <!ATTLIST variable name CDATA #REQUIRED>
	  <!ATTLIST variable access (read-only|read-write|local-player|write-only) "read-write">
	  <!ATTLIST variable version CDATA #IMPLIED>

	  <!ELEMENT accessor ((description?),(length?),(index?),(call?),(function)*)>
	  <!ATTLIST accessor name ID #REQUIRED>
	  <!ATTLIST accessor contains IDREF #REQUIRED>

	  <!ELEMENT enum-accessor ((description?),(length?),(index?),(call?))>
	  <!ATTLIST enum-accessor name ID #REQUIRED>
	  <!ATTLIST enum-accessor contains IDREF #REQUIRED>
	  <!ATTLIST enum-accessor nice-name CDATA #IMPLIED>
	  
	  <!ELEMENT enum ((description?),(function|function-variable|subtable|variable)*,(mnemonics?))>
	  <!ATTLIST enum name ID #REQUIRED>

	  <!ELEMENT mnemonics (mnemonic*)>
	  <!ELEMENT mnemonic EMPTY>

	  <!ATTLIST mnemonic name CDATA #REQUIRED>

	  <!ELEMENT length (description?)>
	  <!ELEMENT index ((description?),(type?))>
	  <!ELEMENT call (description?)>
	  <!ELEMENT type (#PCDATA)>
	  <!ELEMENT alias (#PCDATA)>
	  <!ELEMENT note (#PCDATA)>
	  <!ATTLIST note version CDATA #IMPLIED>
	  ]>
<document title="Aleph One Lua Scripters’ Guide">
  <section name="General" id="general">
    <section name="What is This?" id="what_is_this">
      <description>
		<p>This is a reference for writing Lua scripts to work in Aleph One. It lists every trigger and table available to Lua scripts. It is expected that Lua functionality will grow in Aleph One, and as it does, so will this document. Not everything here is completely documented, and any help fixing that would be appreciated.</p>
		<p>This is not a reference for Lua itself - see lua.org for that.</p>
      </description>
    </section>
    <section name="Running a Script" id="running_a_script">
      <description>
		<p>There are three ways to get a script to run - by embedding it in a level, by selecting a solo script in the Environment Preferences, or by selecting a script at the gather network game dialog.</p>
		<p>To embed a script in a level, use a tool such as Atque. Use embedded Lua scripts only for map specific features, not for modifying game types. For instance, it may be tempting to embed the latest version of the Lua CTF script in a map designed only for playing CTF; however, this would prevent the user from using a later version of CTF if it were to come out, or from using another net script that works on CTF maps. Some older scenarios use Lua scripts in TEXT resources, but this is no longer recommended since they are not transmitted in net games.</p>
		<p>To use a solo script, check the "Use Solo Script" box in Environment Preferences, and choose the script file to use.</p>
		<p>To use a script via the network game dialog, put then script in a text file with the extension .lua. Then, at the gather network game dialog, select "use script", then select your script file.</p>
      </description>
    </section>
    <section name="Units" id="units">
      <description>
		<p>The unit for distance we use is World Units (WU) These are the same values you’d see in Forge or with F10 location display, and 1/1024 of what A1 uses internally and what you’d see in Pfhorte.</p>
		<p>Units for speed are . . . well let’s say they’re messy. :) Lua speeds are expressed in World Units per tick (a tick is 1/30 of a second). Forge claims to use WU per sec, but it actually uses 0.87890625 WU per sec (which equals 30 internal units per tick). The following example illustrates the various conversions:</p>
		<ul>
		  <li><b style="display: inline-block; width: 10em; text-align: right">Actual:</b> 7.5 World Units per second</li>
		  <li><b style="display: inline-block; width: 10em; text-align: right">A1 internal:</b> 256 units per tick (7.5 * 1024 / 30)</li>
		  <li><b style="display: inline-block; width: 10em; text-align: right">Lua:</b> 0.25 WU per tick (7.5 / 30)</li>
		  <li><b style="display: inline-block; width: 10em; text-align: right">Forge:</b> 8.53 "WU per second" ((7.5 * 1024 / 30) / 30)</li>
		</ul>
      </description>
    </section>
	<section name="Net Games and Films" id="sync">
	  <description>
		<p>Aleph One net games distribute a set of player inputs, which are applied to each distributed game world or to the game world in the film being played back. There is a separate copy of the Lua script running on each player’s machine. This means that in order to prevent net games from going out of sync, or films from playing back incorrectly, each of the separately running Lua scripts needs to manipulate the world the exact same way.</p>
		<p>For example, if one player’s Lua script creates a monster, that monsters actions in the game are controlled by the random seed established at the beginning of the game. So, the other players’ scripts must create the same monster the same way, or the net game will go out of sync.</p>
		<p>Usually this is not a problem, as long as scripters avoid functions marked with the "local player" tag, and the two local random functions, which will return different results on different machines. The <code>global_random</code> and <code>random</code> functions will return the same number on different machines, as long as they are called the same number of times, so they are safe to use for net games.</p>
		<p>These rules apply to film playback as well; films will only play back if scripts behave exactly the same way as when the film was recorded</p>
		<p>A few accessors, such as Ephemera and Fog were designed to be used on a "local player" basis without breaking films or net. For instance, it would be safe to programmatically disable fog when a player zooms in by checking <code>Players.local_player.zoom_active</code>--because the mere presence of fog will not cause a net game or film to go out of sync. Likewise, Ephemera can be created based on the Ephemera.quality setting, which will vary from machine to machine. A script that only uses Ephemera can be turned on and off and film playback will be unaffected.</p>
		<p>When using local-safe accessors like Ephemera and Fog, it is important to use the matching <code>random_local</code> function, because it will not affect the progression of the ordinary random functions.</p>
		<p>If this is confusing to you, it would be safest simply to avoid using anything marked with the "local player" tag, as well as the two local random functions and Ephemera.</p>
	  </description>
	</section>
    <section name="Loading Collections" id="loading_collections">
      <description>
		<p>A Lua script can ask for the engine to load collections it might otherwise not load; for instance, in order to be able to spawn defenders and compilers on a map that might not have them otherwise, add the indices for those collections to the global table CollectionsUsed:
		</p><pre>CollectionsUsed = { 10, 16 }</pre>
      </description>
    </section>
    <section name="Persistence" id="persistence">
      <description>
		<p>Lua scripts are only active during a single level. If the user jumps to a new level, or restores from a saved game, the script is restarted in a clean state.</p>
		<p>It is now possible to pass data across level jumps, by using the Game.restore_passed() function. This function will restore any custom fields (see the "Custom Fields" section of "Using Tables" below) in the Players or Game tables that were set immediately prior to the last level jump. Note that in order for data to survive multiple level jumps, Game.restore_passed() must be called after each level jump. Game.restore_passed() will not restore data from saved games.</p>
		<p>It is also possible to restore data from saved games. The Game.restore_saved() function will restore all custom fields in use at the time the game was saved.</p>
		<p>Only numbers, strings, booleans, and tables (including Aleph One’s built-in userdata tables) can be restored.</p>
      </description>
    </section>
  </section>
  <triggers id="triggers">
    <description>These are functions scripts can define which Aleph One will call at specific times or events. For example, to regenerate health:
	<span class="pre">Triggers = {}
function Triggers.idle()
  for p in Players() do 
    if p.life &lt; 150 and not p.dead then 
      p.life = p.life + 1
    end
  end
end
	</span>
	Calling Triggers = {} at the beginning of the script removes the compatibility triggers installed for old Lua scripts, speeding up execution of new scripts.
	</description>
    <function name="init">
      <description>at beginning of level</description>
      <argument name="restoring_game">
		<description>true if restoring from a saved game</description>
		<type>boolean</type>
      </argument>
    </function>
    <function name="cleanup">
      <description>at end of the level</description>
      <note>primarily this is intended as a last chance for changing netgame scores before the postgame carnage report.</note>
    </function>
    <function name="idle">
      <description>at each tick, before physics and such</description>
    </function>
    <function name="postidle">
      <description>at each tick, after physics and such, but before rendering</description>
    </function>
    <function name="start_refuel">
      <description>whenever a player starts to use a refuel panel</description>
      <argument name="class"><type>control_panel_class</type></argument>
      <argument name="player"><type>player</type></argument>
      <argument name="side"><type>side</type></argument>
    </function>
    <function name="end_refuel">
      <description>whenever a player stops using a refuel panel</description>
      <argument name="class"><type>control_panel_class</type></argument>
      <argument name="player"><type>player</type></argument>
      <argument name="side"><type>side</type></argument>
    </function>
    <function name="tag_switch">
      <description>whenever a player uses a tag switch</description>
      <argument name="tag"><type>tag</type></argument>
      <argument name="player"><type>player</type></argument>
      <argument name="side"><type>side</type></argument>
      <note>not called when a projectile (e.g., fists) toggles a tag switch</note>
      <note>side is only valid in version 20111201 and newer</note>
    </function>
    <function name="light_switch">
      <description>whenever a player uses a light switch</description>
      <argument name="light"><type>light</type></argument>
      <argument name="player"><type>player</type></argument>
      <argument name="side"><type>side</type></argument>
      <note>not called when a projectile (e.g., fists) toggles a light switch</note>
      <note>side is only valid in version 20111201 and newer</note>
    </function>
    <function name="platform_switch">
      <description>whenever a player uses a platform switch</description>
      <argument name="polygon">
		<type>polygon</type>
		<description>polygon of the platform being toggled</description>
      </argument>
      <argument name="player"><type>player</type></argument>
      <argument name="side"><type>side</type></argument>
      <note>not called when a projectile (e.g., fists) toggles a platform switch</note>
      <note>side is only valid in version 20111201 and newer</note>
    </function>
    <function name="projectile_switch" version="20111201">
      <description>whenever a projectile toggles a switch</description>
      <argument name="projectile">
		<type>projectile</type>
		<description>projectile that toggled the switch</description>
      </argument>
      <argument name="side">
		<type>side</type>
		<description>side containing switch being toggled</description>
      </argument>
    </function>
    <function name="terminal_enter">
      <description>whenever a player starts using a terminal</description>
      <argument name="terminal"><type>terminal</type></argument>
      <argument name="player"><type>player</type></argument>
    </function>
    <function name="terminal_exit">
      <description>whenever a player stops using a terminal</description>
      <argument name="terminal"><type>terminal</type></argument>
      <argument name="player"><type>player</type></argument>
    </function>
    <function name="pattern_buffer">
      <description>whenever a player uses a pattern buffer</description>
      <argument name="side"><type>side</type></argument>
      <argument name="player"><type>player</type></argument>
    </function>
    <function name="got_item">
      <description>whenever a player picks up an item</description>
      <argument name="type"><type>item_type</type></argument>
      <argument name="player"><type>player</type></argument>
      <note>also whenever a player gets an item when a script calls .items.add()</note>
    </function>
    <function name="light_activated">
      <description>whenever a light is activated or deactivated</description>
      <argument name="light"><type>light</type></argument>
    </function>
    <function name="platform_activated">
      <description>whenever a platform is activated or deactivated</description>
      <argument name="polygon"><type>polygon</type></argument>
    </function>
    <function name="player_revived">
      <description>whenever a player revives (presumably only happens in a netgame)</description>
      <argument name="player"><type>player</type></argument>
    </function>
    <function name="player_killed">
      <description>whenever a player dies</description>
      <argument name="player"><type>player</type></argument>
      <argument name="aggressor_player">
		<description>the player who killed player, possibly himself (suicide) (can be nil)</description>
	  <type>player</type></argument>
      <argument name="action">
		<description>dying soft, dying hard, or dying flaming</description>
	  <type>monster_action</type></argument>
      <argument name="projectile">
		<description>the projectile that delivered the final blow (can be nil)</description>
	  <type>projectile</type></argument>
    </function>
    <function name="player_damaged">
      <description>whenever a player has taken damage, but before he dies if applicable. The player’s suit energy or oxygen may be negative when this trigger is called; if it still is when the trigger returns, it will be set to 0. The player’s suit energy is tested again after this trigger returns, so a script may prevent a player’s death
      </description>
      <argument name="victim">
		<type>player</type>
      </argument>
      <argument name="aggressor_player">
		<description>player who got the kill (can be nil)</description>
		<type>player</type>
      </argument>
      <argument name="aggressor_monster">
		<description>monster that got the kill (can be nil)</description>
		<type>monster</type>
      </argument>
      <argument name="damage_type">
		<description>e.g. "fists"</description>
		<type>damage_type</type>
      </argument>
      <argument name="damage_amount">
		<description>the amount recently subtracted from the player. If "oxygen drain", damage_amount was assessed against player’s oxygen; otherwise against player’s suit energy</description>
		<type>number</type>
      </argument>
      <argument name="projectile">
		<description>the projectile that delivered the damage (can be nil)</description>
		<type>projectile</type>
      </argument>
    </function>
    <function name="monster_damaged" version="20100118">
      <description>whenever a monster is damaged, but before it dies if applicable. The monster’s vitality may be negative when this trigger is called. Ther monster’s vitality will be tested again after this trigger returns, so a script may prevent a monster’s death</description>
      <argument name="monster">
		<type>monster</type>
      </argument>
      <argument name="aggressor_monster">
		<description>the monster that caused the damage (can be nil)</description>
		<type>monster</type>
      </argument>
      <argument name="damage_type">
		<description>e.g. "fists"</description>
		<type>damage_type</type>
      </argument>
      <argument name="damage_amount">
		<description>the amount recently subtracted from the monster’s vitality</description>
		<type>number</type>
      </argument>
      <argument name="projectile">
		<description>the projectile that delivered the damage (can be nil)</description>
		<type>projectile</type>
      </argument>
    </function>
    <function name="monster_killed">
      <description>whenever a monster dies</description>
      <argument name="monster"><type>monster</type></argument>
      <argument name="aggressor_player">
		<description>player who killed it (can be nil)</description>
		<type>player</type>
      </argument>
      <argument name="projectile">
		<description>projectile that delivered the final blow (can be nil)</description>
		<type>projectile</type>
      </argument>
      <note>called after a monster has taken lethal damage, but before it’s removed from the monster list</note>
      <note>you can use this to find out when a monster created with new_monster dies, but a monster discovered by Polygons.monsters() may have already taken lethal damage, so you may need to check for that case when using Polygons.monsters()</note>
    </function>
    <function name="item_created">
      <description>whenever an item is created and placed on the ground (or floating) somewhere</description>
      <argument name="item"><type>item</type></argument>
      <note>does not trigger on initial item placement because the initial item placement is done before Lua becomes initialised.</note>
    </function>
    <function name="projectile_created" version="20150619">
      <description>whenever a projectile is created</description>
      <argument name="projectile"><type>projectile</type></argument>
    </function>
    <function name="projectile_detonated">
      <description>whenever a projectile detonates, after it has done any area of effect damage</description>
      <argument name="type"><type>projectile_type</type></argument>
      <argument name="owner"><type>monster</type></argument>
      <argument name="polygon"><type>polygon</type></argument>
      <argument name="x"><type>WU</type></argument>
      <argument name="y"><type>WU</type></argument>
      <argument name="z"><type>WU</type></argument>
	  <argument name="t" version="20210408"><type>variant</type></argument>
	  <note>t can be a side, polygon_floor, polygon_ceiling, monster, scenery, polygon; see Polygon:check_collision for info on how to decode. It can also be nil, in the rare case a projectile detonates without hitting something</note>
    </function>
	<function name="calculate_level_completion_state" version="20240712">
	  <description>replaces the classic completion state calculation</description>
	  <return><type>CompletionState</type></return>
	</function>
	<function name="monster_kamikazed" version="20240712">
	  <description>whenever a monster kamikazes</description>
	  <argument name="monster"><type>monster</type></argument>
	</function>
  </triggers>
  <section id="using_tables" name="Using Tables">
    <description><p>There are numerous tables (technically, userdata) defined in Aleph One which scripts can use to access objects in the game. A complete list is below.</p>
    <p>Unless otherwise specified, these tables are only valid inside the trigger calls listed above. Attempting to use them in the main body of a script may cause an error in this version or a future version of Aleph One.</p></description>
    <section id="custom" name="Custom Fields">
      <description><p>In a real Lua table, you can set any field you want. In order to help troubleshooting, Aleph One’s userdata tables will only accept the fields listed in the documentation below. However, by prepending an underscore, custom fields can be indexed. These custom fields will be associated with the object until it is destroyed.</p><pre>Players[0]._favorite_flavor = "chocolate"</pre></description>
    </section>
    <section id="table_indices" name="Index">
      <description><p>Each table has a read-only .index variable, that corresponds to the engine’s internal index.</p><pre>=Players[0].index<br/>0</pre></description>
    </section>
    <section id="table_is" name="is_ Functions">
      <description><p>Aleph One installs a set of boolean functions that can be used to recognize each of the userdata table types. For example, <code>is_monster(Monsters[1])</code> returns true. Each of these functions begins with the "is_" prefix.</p></description>
    </section>
  </section>
  <tables id="tables">
    <table name="annotation">
      <variable name="polygon">
		<description>polygon this annotation is associated with</description>
		<type>polygon</type>
		<note>can be nil</note>
		<note>an annotation is only shown when its polygon is visible on the overhead map</note>
      </variable>
      <variable name="text">
		<description>annotation text (64 characters max)</description>
		<type>string</type>
      </variable>
      <variable name="x">
		<type>WU</type>
      </variable>
      <variable name="y">
		<type>WU</type>
      </variable>
    </table>
    <table name="camera">
      <function name="activate">
		<description>activate camera for player</description>
		<argument name="player"><type>player</type></argument>
      </function>
      <function name="clear">
		<description>deletes all path points and angles</description>
      </function>
      <function name="deactivate">
		<description>deactivates camera</description>
      </function>
      <subtable name="path_angles" classname="lua_path_angles">
		<function name="new">
		  <description>adds a path angle</description>
		  <argument name="yaw"><type>angle</type></argument>
		  <argument name="pitch"><type>pitch</type></argument>
		  <argument name="time"><type>time</type></argument>
		</function>
      </subtable>
      <subtable name="path_points" classname="lua_path_points">
		<function name="new">
		  <description>adds a path point</description>
		  <argument name="x"><type>WU</type></argument>
		  <argument name="y"><type>WU</type></argument>
		  <argument name="z"><type>WU</type></argument>
		  <argument name="polygon"><type>polygon</type></argument>
		  <argument name="time"><type>time</type></argument>
		</function>
      </subtable>
    </table>
    <table name="effect">
      <function name="delete" version="20111201">
		<description>removes effect from map</description>
      </function>
      <variable name="facing" version="20111201">
		<description>direction effect is facing</description>
		<type>degrees</type>
      </variable>
      <function name="play_sound" version="20111201">
		<description>play sound coming from this effect</description>
		<argument name="sound"><type>sound</type></argument>
      </function>
      <variable name="polygon" access="read-only" version="20111201">
		<description>polygon the effect is in</description>
		<type>polygon</type>
      </variable>
      <function name="position" version="20111201">
		<description>sets position of effect</description>
		<argument name="x">
		<type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
      </function>
      <variable name="type" access="read-only" version="20111201">
		<description>type of effect</description>
		<type>effect_type</type>
      </variable>
      <variable name="x" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
    </table>
    <table name="endpoint">
      <variable name="x" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<type>WU</type>
      </variable>
    </table>
    <table name="game" singleton="true">
      <function name="autosave" version="20250302">
		<description>saves the game without prompting the user, if possible</description>
		<note>solo only</note>
      </function>
      <variable name="dead_players_drop_items" version="20150619">
        <description>whether dead players drop items</description>
        <type>boolean</type>
      </variable>
      <function name="deserialize" version="20200830">
        <description>deserializes s and returns the original Lua value</description>
        <argument name="s"><type>string</type></argument>
        <return><type>value</type></return>
        <note>see Game.serialize</note>
      </function>
      <variable name="difficulty" access="read-only">
		<description>the difficulty level</description>
		<type>difficulty_type</type>
      </variable>
      <function name="global_random">
		<description>returns a random number between 0 and n-1 from Aleph One’s original random number generator</description>
		<argument name="n"><type>number</type></argument>
		<return><type>number</type></return>
      </function>
      <variable name="kill_limit" access="read-only">
		<description>the game kill limit, or 0 if there is none</description>
		<type>number</type>
      </variable>
	  <function name="local_random">
		<description>returns a random number between 0 and n-1 from Aleph One’s original random number generator</description>
		<argument name="n"><type>number</type></argument>
		<return><type>number</type></return>
		<note>use only for local player effects (see Net Games and Films)</note>
      </function>
      <variable name="monsters_replenish" version="20111201">
		<description>whether monsters spawn or not; in a net game, this corresponds to the "Aliens" checkbox</description>
		<type>boolean</type>
		<note>this can suppress initial monster placement, if set to false directly when the script is loaded</note>
      </variable>
      <variable name="nonlocal_overlays" version="20200830">
		<description>When false, only the local player’s overlays are used, and only prints to the local player will be displayed. When true, the overlays and prints of whatever player is currently being viewed will apply. This defaults to false for compatibility with scripts that depend on the old behavior.</description>
		<type>boolean</type>
      </variable>
      <variable name="over" access="write-only">
		<description>Use this variable to override the game’s default scoring behavior. If set to false, the game will not end due to a score limit. If set to true, the game ends immediately. If left unset or if set to nil, the game will end if a score limit is reached. (Note that you cannot prevent the game from ending due to a time limit.)</description>
		<type>boolean</type>
      </variable>
	  <variable name="player" version="git">
		<description>In Tag games, the player who is It. In Kill the Man With the Ball or Rugby games, the player who is carrying the ball</description>
		<type>Player</type>
		<note>writing to this will only work in Tag games</note>
	  </variable>
      <variable name="proper_item_accounting" version="20100118">
		<description>When true, the current item counts on the map are updated properly when Lua deletes map items and changes player inventories. This defaults to false to preserve film playback with older scripts. New scripts that manipulate items should always set this to true.</description>
		<type>boolean</type>
      </variable>
      <function name="random">
		<description>returns a random number between 0 and n-1 using a good random number generator</description>
		<argument name="n"><type>number</type></argument>
		<return><type>number</type></return>
      </function>
	  <function name="random_local" version="20210408">
		<description>returns a random number between 0 and n-1 using a good random number generator</description>
		<argument name="n"><type>number</type></argument>
		<return><type>number</type></return>
		<note>use only for local player effects (see Net Games and Films)</note>
	  </function>
	  <variable name="replay" access="read-only" version="20221126">
		<description>is the script being run during a film replay</description>
		<return><type>boolean</type></return>
		<note>use sparingly; altering the world differently during a replay than during live playback will cause the replay go out of sync</note>
	  </variable>
      <function name="restore_passed" version="20090909">
		<description>tries to restore any Player or Game custom fields from before the last level jump; returns true if custom fields were successfully restored</description>
		<note>if successful, overwrites all existing Player or Game custom fields</note>
		<return><type>boolean</type></return>
      </function>
      <function name="restore_saved" version="20090909">
		<description>tries to restore any custom fields from the saved game; returns true if custom fields were successfully restored</description>
		<note>if successful, overwrites all existing custom fields</note>
		<return><type>boolean</type></return>
      </function>
      <function name="save">
		<description>saves the game (as if the user had activated a pattern buffer)</description>
		<note>solo only</note>
      </function>
	  <variable name="scoring_mode">
		<description>the current scoring mode (if the gametype is "custom")</description>
		<type>scoring_mode_type</type>
      </variable>
      <function name="serialize" version="20200830">
        <description>serializes v into a binary string</description>
        <argument name="v"><type>value</type></argument>
        <return><type>string</type></return>
        <note>only numbers, strings, booleans, and tables (including Aleph One’s built-in userdata tables) can be serialized</note>
      </function>
      <variable name="ticks" access="read-only">
		<description>ticks since game started</description>
		<type>time</type>
      </variable>
	   <variable name="time_remaining" access="read-only">
		<description>the number of ticks until the game ends, or nil if there is no time limit</description>
		<type>number</type>
      </variable>
      
      <variable name="type" access="read-only">
		<description>whether the game is EMFH, KOTH, etc.</description>
		<type>game_type</type>
      </variable>
      <variable name="version" access="read-only">
		<description>the date version of the local player’s engine</description>
		<note>for example, "20071103"</note>
      </variable>
    </table>
    <table name="goal">
      <variable name="facing" access="read-only" version="20111201">
		<description>direction goal is facing</description>
		<type>degrees</type>
      </variable>
      <variable name="polygon" access="read-only" version="20111201">
		<description>polygon the goal is in</description>
		<type>polygon</type>
      </variable>
      <variable name="id" access="read-only" version="20111201">
		<description>ID number of goal</description>
		<type>number</type>
      </variable>
      <variable name="x" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only" version="20111201">
		<type>WU</type>
		<note>from floor or ceiling</note>
      </variable>
    </table>
    <table name="item">
      <function name="delete">
		<description>removes item from map</description>
      </function>
      <variable name="facing">
		<description>direction item is facing</description>
		<type>degrees</type>
      </variable>
      <function name="play_sound">
		<description>play sound coming from this item</description>
		<argument name="sound"><type>sound</type></argument>
      </function>
      <variable name="polygon" access="read-only">
		<description>polygon the item is in</description>
		<type>polygon</type>
      </variable>
      <function name="position" version="20090909">
		<description>sets position of item</description>
		<argument name="x">
		<type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
      </function>
	  <function name="teleport_in" version="20240712">
		<description>teleports item in</description>
		<note>can fail silently if there are not enough effects slots</note>
	  </function>
	  <function name="teleport_out" version="20240712">
		<description>teleports item out</description>
		<note>can fail silently if there are not enough effects slots</note>
	  </function>
      <variable name="type" access="read-only">
		<description>type of item</description>
		<type>item_type</type>
      </variable>
      <variable name="visible" version="20240712">
    <type>boolean</type>
      </variable>
      <variable name="x" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only">
		<type>WU</type>
      </variable>
    </table>
    <table name="item_start">
      <variable name="facing" access="read-only" version="20111201">
		<description>direction item is initially facing</description>
		<type>angle</type>
      </variable>
      <variable name="from_ceiling" access="read-only" version="20111201">
		<description>whether item location z is from ceiling</description>
		<type>boolean</type>
      </variable>
      <variable name="invisible" access="read-only" version="20111201">
		<description>whether item will teleport in</description>
		<type>boolean</type>
      </variable>
      <variable name="polygon" access="read-only" version="20111201">
		<description>item starting location polygon</description>
		<type>polygon</type>
      </variable>
      <variable name="type" access="read-only" version="20111201">
		<description>type of item</description>
		<type>item_type</type>
      </variable>
      <variable name="x" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only" version="20111201">
		<type>WU</type>
		<note>from floor or ceiling</note>
      </variable>
    </table>

    <table name="level" singleton="true">
      <function name="calculate_completion_state" version="20081213">
		<description>returns whether level is finished, unfinished, or failed</description>
		<return><type>completion_state</type></return>
		<note>does not call the trigger, so it can be used in the trigger</note>
      </function>
      <variable name="completed" access="read-only" version="20111201">
		<description>check this in Triggers.cleanup() to determine whether the player(s) teleported out</description>
		<type>boolean</type>
      </variable>
      <variable name="extermination" access="read-only" version="20081213">
		<description>whether level has extermination flag set</description>
		<type>boolean</type>
      </variable>
      <variable name="exploration" access="read-only" version="20081213">
		<description>whether level has exploration flag set</description>
		<type>boolean</type>
      </variable>
      <subtable name="fog" classname="lua_fog">
		<alias>underwater_fog</alias>
		<variable name="active">
		  <alias>present</alias>
		  <description>whether fog is present</description>
		  <type>boolean</type>
		</variable>
		<variable name="affects_landscapes">
		  <description>whether fog affects landscapes</description>
		  <type>boolean</type>
		</variable>
		<subtable name="color" classname="lua_fog_color">
		  <note>values range from 0.0 to 1.0</note>
		  <variable name="r">
			<description>red</description>
			<type>number</type>
		  </variable>
		  <variable name="g">
			<description>green</description>
			<type>number</type>
		  </variable>
		  <variable name="b">
			<description>blue</description>
			<type>number</type>
		  </variable>
		</subtable>
		<variable name="depth">
		  <description>fog depth in WU</description>
		  <type>number</type>
		</variable>
		<variable name="landscape_mix" version="20231125">
		  <description>amount of fog to mix into landscape</description>
		  <type>number</type>
		  <note>values range from 0.0 to 1.0</note>
		</variable>
		<variable name="mode" version="20231125">
		  <description>linear, exp, or exp2</description>
		  <type>fog_mode</type>
		</variable>
		<variable name="start" version="20231125">
		  <description>fog start in WU</description>
		  <type>number</type>
		  <note>only applies to linear fog</note>
		</variable>
      </subtable>
      <variable name="low_gravity" access="read-only">
		<description>whether level is low gravity</description>
		<type>boolean</type>
      </variable>
      <variable name="magnetic" access="read-only">
		<description>whether level is magnetic</description>
		<type>string</type>
      </variable>
      <variable name="name" access="read-only">
		<description>level name</description>
		<type>string</type>
      </variable>
      <variable name="index" access="read-only" version="20150619">
		<description>level index in the map file (starting from 0)</description>
		<type>number</type>
      </variable>
      <variable name="map_checksum" access="read-only" version="20150619">
		<description>checksum of map file</description>
		<type>number</type>
      </variable>
      <variable name="rebellion" access="read-only">
		<description>whether level is rebellion</description>
		<type>boolean</type>
      </variable>
      <variable name="repair" access="read-only" version="20081213">
		<description>whether level has repair flag set</description>
		<type>boolean</type>
      </variable>
      <variable name="rescue" access="read-only" version="20081213">
		<description>whether level has rescue flag set</description>
		<type>boolean</type>
      </variable>
      <variable name="retrieval" access="read-only" version="20081213">
		<description>whether level has retrieval flag set</description>
		<type>boolean</type>
      </variable>
      <variable name="stash[key]" version="20200830">
        <description>reads/writes values to a stash shared between all running Lua scripts</description>
        <note>keys/values must be strings</note>
        <type>string</type>
      </variable>
      <variable name="vacuum" access="read-only">
		<description>whether level is vacuum</description>
		<type>boolean</type>
      </variable>
    </table>
	<table name="ephemera">
	  <variable name="clut_index">
		<type>number</type>
		<description>color table of this ephemera</description>
	  </variable>
	  <variable name="collection">
		<type>collection</type>
		<description>shape collection of this ephemera</description>
	  </variable>
	  <variable name="end_when_animation_loops">
		<type>boolean</type>
		<description>if set, ephemera is removed once animation finishes</description>
	  </variable>
	  <function name="delete">
		<description>removes ephemera from the level</description>
	  </function>
	  <variable name="enlarged">
		<type>boolean</type>
		<description>ephemera is rendered 25% bigger</description>
	  </variable>
	  <variable name="facing">
		<type>angle</type>
		<description>direction the ephemera is facing</description>
	  </variable>
	  <function name="position">
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<description>sets position of ephemera</description>
	  </function>
	  <variable name="polygon" access="read-only">
		<type>polygon</type>
		<description>polygon this ephemera is in</description>
	  </variable>
	  <variable name="rendered" access="read-only">
		<type>boolean</type>
		<description>whether this ephemera was recently rendered</description>
		<note>you can use this to skip updating ephemera that aren’t currently visible</note>
	  </variable>
	  <variable name="shape_index">
		<type>number</type>
		<description>shape index of ephemera</description>
		<note>Anvil calls this sequence</note>
	  </variable>
	  <variable name="tiny">
		<type>boolean</type>
		<description>ephemera is rendered 50% size</description>
	  </variable>
	  <variable name="valid" access="read-only">
		<type>boolean</type>
		<description>whether ephemera is still valid</description>
	  </variable>
	  <variable name="x" access="read-only">
		<type>WU</type>
	  </variable>
	  <variable name="y" access="read-only">
		<type>WU</type>
	  </variable>
	  <variable name="z" access="read-only">
		<type>WU</type>
	  </variable>
	</table>
    <table name="light">
      <variable name="active">
		<description>whether light is active</description>
		<type>boolean</type>
      </variable>
      <variable name="tag" version="20100118">
		<description>tag of light</description>
		<type>tag</type>
      </variable>
      <variable name="initial_phase" version="20100118">
		<description>phase the light starts with</description>
		<type>time</type>
      </variable>
      <variable name="initially_active" version="20100118">
		<description>whether the light was initially active</description>
		<type>boolean</type>
      </variable>
      <variable name="intensity" access="read-only" version="20100118">
		<description>current intensity for this light (range: 0-1)</description>
		<type>number</type>
      </variable>
      <subtable-accessor name="states" classname="light_state_subtable" index="light_type">
		<variable name="delta_intensity" version="20100118">
		  <description>random intensity change for this state</description>
		  <type>number</type>
		</variable>
		<variable name="delta_period" version="20100118">
		  <description>random period change for this state</description>
		  <type>time</type>
		</variable>
		<variable name="light_function" version="20100118">
		  <description>light function for this state</description>
		  <type>light_function</type>
		</variable>
		<variable name="intensity" version="20100118">
		  <description>intensity for this state</description>
		  <type>number</type>
		</variable>
		<variable name="period" version="20100118">
		  <description>period for this state</description>
		  <type>number</type>
		</variable>
      </subtable-accessor>
    </table>
    <table name="line">
      <variable name="clockwise_polygon" access="read-only">
		<alias>cw_polygon</alias>
		<description>polygon on clockwise side of line</description>
		<type>polygon</type>
      </variable>
      <variable name="clockwise_side" access="read-only">
		<alias>cw_side</alias>
		<description>clockwise side of line</description>
		<type>side</type>
      </variable>
      <variable name="counterclockwise_polygon" access="read-only">
		<alias>ccw_polygon</alias>
		<description>polygon on counterclockwise side of line</description>
		<type>polygon</type>
      </variable>
      <variable name="counterclockwise_side" access="read-only">
		<alias>ccw_side</alias>
		<description>counterclockwise side of line</description>
		<type>side</type>
      </variable>
	  <variable name="decorative" version="20210408">
		<description>projectiles always pass the transparent sides of decorative lines</description>
		<type>bool</type>
	  </variable>
      <subtable-accessor name="endpoints" classname="line_endpoints" index="n">
		<description>returns line endpoint n</description>
      </subtable-accessor>
      <variable name="has_transparent_side" access="read-only" version="20080707">
		<description>whether one of the line’s sides has a transparent texture</description>
		<type>boolean</type>
      </variable>
      <variable name="highest_adjacent_floor" access="read-only" version="20080707">
		<description>height of higher adjacent polygon floor</description>
		<type>WU</type>
      </variable>
      <variable name="length" access="read-only">
		<description>the length of this line</description>
		<note>this might not be accurate, if someone used Chisel’s stretch plugin</note>
      </variable>
      <variable name="lowest_adjacent_ceiling" access="read-only" version="20080707">
		<description>height of lower adjacent polygon ceiling</description>
		<type>WU</type>
      </variable>
      <variable name="solid" access="read-only" version="20080707">
		<description>whether line is solid</description>
		<type>boolean</type>
      </variable>
      <variable name="visible_on_automap" version="20150619">
		<description>whether line is revealed on local player’s automap</description>
		<type>boolean</type>
      </variable>
    </table>
    <table name="media">
      <variable name="direction" version="20100118">
		<description>direction of media</description>
		<type>angle</type>
      </variable>
      <variable name="height" access="read-only" version="20100118">
		<description>height of media</description>
		<type>WU</type>
      </variable>
      <variable name="high" version="20100118">
		<description>high tide of media</description>
		<type>WU</type>
      </variable>
      <variable name="light" version="20100118">
		<description>light that controls this media’s tide</description>
		<type>light</type>
      </variable>
      <variable name="low" version="20100118">
		<description>low tide of media</description>
		<type>WU</type>
      </variable>
      <variable name="speed" version="20100118">
		<description>speed of media</description>
		<type>speed</type>
      </variable>
      <variable name="type" access="read-only">
		<description>type of media</description>
		<type>media_type</type>
      </variable>
      <variable name="type" version="20100118">
		<description>type of media</description>
		<type>media_type</type>
      </variable>
    </table>
    <table name="monster">
      <function name="accelerate" version="20081213">
		<description>accelerates monster</description>
		<argument name="direction"><type>angle</type></argument>
		<argument name="velocity"><type>speed</type></argument>
		<argument name="vertical_velocity"><type>speed</type></argument>
      </function>
      <variable name="action" access="read-only">
		<description>current AI action of the monster</description>
		<type>number</type>
      </variable>
      <variable name="active">
		<description>whether monster has been activated</description>
		<type>boolean</type>
      </variable>
      <function name="attack">
		<description>instructs monster to attack target</description>
		<argument name="target"><type>monster</type></argument>
      </function>
	  <variable name="blind" version="20210408">
		<description>monster is blind</description>
		<note>only valid before monster activates</note>
		<type>boolean</type>
	  </variable>
      <function name="damage">
		<description>damages monster</description>
		<argument name="amount"><type>number</type></argument>
		<argument name="type" required="false"><type>damage_type</type></argument>
		<note>if no type is specified, fist damage is dealt</note>
      </function>
	  <variable name="deaf" version="20210408">
		<description>monster is deaf</description>
		<note>only valid before monster activates</note>
		<type>boolean</type>
	  </variable>
	  <function name="delete" version="20210408">
		<description>deletes monster</description>
	  </function>
      <variable name="external_velocity" version="20090909">
		<description>monster’s current external velocity (always in the opposite direction of facing)</description>
		<type>speed</type>
      </variable>
      <variable name="facing">
		<alias>yaw</alias>
		<description>direction the monster is facing</description>
		<type>degrees</type>
      </variable>
      <variable name="life">
		<alias>vitality</alias>
		<description>the monster’s vitality</description>
		<type>number</type>
		<note>monsters that haven’t spawned or teleported in yet don’t have vitality</note>
      </variable>
      <variable name="mode" access="read-only">
		<description>current AI mode of the monster</description>
		<type>number</type>
      </variable>
      <function name="move_by_path">
		<description>instructs monster to move to polygon</description>
		<argument name="polygon"><type>polygon</type></argument>
		<note>monsters get distracted easily en route</note>
		<note>once it gets there, it probably won’t choose to stay</note>
      </function>
      <variable name="player" access="read-only">
		<description>if monster is a player monster, the player; otherwise, nil</description>
		<type>player</type>
      </variable>
      <function name="play_sound">
		<description>plays sound coming from this monster</description>
		<argument name="sound"><type>sound</type></argument>
      </function>
      <variable name="polygon" access="read-only">
		<description>polygon this monster is in</description>
		<type>polygon</type>
      </variable>
      <function name="position">
		<description>sets position of monster</description>
		<argument name="x">
		<type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
      </function>
	  <variable name="teleports_out" version="20210408">
		<description>monster teleports out when deactivated</description>
		<type>boolean</type>
	  </variable>
      <variable name="type" access="read-only">
		<description>type of monster</description>
		<type>monster_type</type>
      </variable>
      <variable name="valid" access="read-only">
		<description>whether monster is still valid</description>
		<type>boolean</type>
      </variable>
      <variable name="vertical_velocity" version="20090909">
		<description>monster’s current vertical external velocity</description>
		<type>speed</type>
      </variable>
      <variable name="visible">
		<description>whether monster is visible (e.g. has teleported in)</description>
		<type>boolean</type>
		<note>this has nothing to do with whether monsters are cloaked (like invisible S’pht) or not</note>
		<note>only writable before the monster is activated</note>
      </variable>
      <variable name="x" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only">
		<type>WU</type>
      </variable>
    </table>
    <table name="monster_start">
      <variable name="blind" access="read-only" version="20111201">
		<description>whether monster is activated by sight</description>
		<type>boolean</type>
      </variable>
      <variable name="deaf" access="read-only" version="20111201">
		<description>whether monster is activated by sound</description>
		<type>boolean</type>
      </variable>
      <variable name="facing" access="read-only" version="20111201">
		<description>direction monster is initially facing</description>
		<type>angle</type>
      </variable>
      <variable name="from_ceiling" access="read-only" version="20111201">
		<description>whether monster location z is from ceiling</description>
		<type>boolean</type>
      </variable>
      <variable name="invisible" access="read-only" version="20111201">
		<description>whether monster will teleport in when activated</description>
		<type>boolean</type>
      </variable>
      <variable name="polygon" access="read-only" version="20111201">
		<description>monster starting location polygon</description>
		<type>polygon</type>
      </variable>
      <variable name="type" access="read-only" version="20111201">
		<description>type of monster</description>
		<type>monster_type</type>
      </variable>
      <variable name="x" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only" version="20111201">
		<type>WU</type>
		<note>from floor or ceiling</note>
      </variable>
    </table>
    <table name="music">
	  <function name="play" version="20231125">
		<description>plays the music</description>
		<note>if the music was stopped, restarts it</note>
	  </function>
	  <function name="stop" version="20231125">
		<description>stops the music</description>
	  </function>
	  <function name="fade" version="20231125">
		<description>fades the music</description>
		<argument name="volume"><type>number</type></argument>
		<argument name="duration" required="false"><type>seconds</type></argument>
		<argument name="stop_after_fade" required="false"><type>boolean</type></argument>
		<note>it will fade in until volume is reached. volume is decimal [0 - 1]</note>
		<note>duration unit is seconds and is 1 if not specified</note>
		<note>stop_after_fade is disabled by default, if set to true if the volume reaches 0 while fading the music will automatically stop</note>
	  </function>
	  <variable name="volume" version="20231125">
		<description>the volume of the music</description>
		<type>number</type>
		<note>volume is decimal [0 - 1]</note>
	  </variable>
	  <variable name="active" access="read-only" version="20231125">
		<description>returns true if the music is still playing</description>
		<type>boolean</type>
	  </variable>
    </table>
    <table name="platform">
	  <variable name="activates_adjacent_platforms_at_each_level" version="20210408">
		<description>platform will activate adjacent platforms at each elevation it comes to (ie.,at floor level and ceiling level)</description>
		<type>boolean</type>
	  </variable>
	  <variable name="activates_adjacent_platforms_when_activating" version="20210408">
		<description>when activating, this platform activates adjacent platforms</description>
		<type>boolean</type>
	  </variable>
	   <variable name="activates_adjacent_platforms_when_deactivating" version="20210408">
		<description>when deactivating, this platform activates adjacent platforms</description>
		<type>boolean</type>
	  </variable>
	  <variable name="activates_light" version="20210408">
		<description>activates floor and ceiling lightsources while activating</description>
		<type>boolean</type>
	  </variable>
	  <variable name="activates_only_once" version="20210408">
		<description>cannot be activated a second time</description>
		<type>boolean</type>
	  </variable>
      <variable name="active">
		<description>whether platform is currently active</description>
		<type>boolean</type>
      </variable>
	  <variable name="cannot_be_externally_deactivated" version="20210408">
		<description>when active, can only be deactivated by itself</description>
		<type>boolean</type>
	  </variable>
      <variable name="ceiling_height">
		<description>current ceiling height of platform</description>
		<type>WU</type>
      </variable>
	  <variable name="comes_from_ceiling" version="20210408" access="read-only">
		<description>platform lowers from ceiling</description>
		<type>boolean</type>
	  </variable>
	  <variable name="comes_from_floor" version="20210408" access="read-only">
		<description>platform rises from floor</description>
		<type>boolean</type>
	  </variable>
      <variable name="contracting">
		<description>direction platform is moving or will move when active</description>
		<type>boolean</type>
      </variable>
	  <variable name="contracts_slower" version="20210408">
		<description>will move slower when contracting than when extending</description>
		<type>boolean</type>
	  </variable>
	  <variable name="deactivates_adjacent_platforms_when_activating" version="20210408">
		<description>when activating, this platform deactivates adjacent platforms</description>
		<type>boolean</type>
	  </variable>
	  <variable name="deactivates_adjacent_platforms_when_deactivating" version="20210408">
		<description>when deactivating, this platform deactivates adjacent platforms</description>
		<type>boolean</type>
	  </variable>
	  <variable name="deactivates_at_each_level" version="20210408">
		<description>this platform will deactivate each time it reaches a discrete level</description>
		<type>boolean</type>
	  </variable>
	  <variable name="deactivates_at_initial_level" version="20210408">
		<description>this platform will deactivate upon returning to its initial position</description>
		<type>boolean</type>
	  </variable>
	  <variable name="deactivates_light" version="20210408">
		<description>deactivates floor and ceiling lightsources while deactivating</description>
		<type>boolean</type>
	  </variable>
	  <variable name="delays_before_activation" version="20210408">
		<description>whether or not the platform begins with the maximum delay before moving</description>
		<type>boolean</type>
	  </variable>
	  <variable name="does_not_activate_parent" version="20210408">
		<description>does not reactive its parent (the platform which activated it)</description>
		<type>boolean</type>
	  </variable>
      <variable name="door" version="20100118">
		<description>platform is a door</description>
		<type>boolean</type>
      </variable>
      <variable name="extending">
		<description>direction platform is moving or will move when active</description>
		<type>boolean</type>
      </variable>
	  <variable name="extends_floor_to_ceiling" version="20210408" access="read-only">
		<description>there is no empty space when the platform is fully extended</description>
		<type>boolean</type>
      </variable>
      <variable name="floor_height">
		<description>current floor height of platform</description>
		<type>WU</type>
      </variable>
	  <variable name="initially_active" version="20210408" access="read-only">
		<description>otherwise inactive</description>
		<type>boolean</type>
	  </variable>
	  <variable name="has_been_activated" version="20210408">
		<description>in case platform can only be activated once</description>
		<type>boolean</type>
	  </variable>
	  <variable name="initially_extended" version="20210408" access="read-only">
		<description>high for floor platforms, low for ceiling platforms, closed for two-way platforms</description>
		<type>boolean</type>
	  </variable>
      <variable name="locked" version="20100118">
		<description>platform is locked</description>
		<type>boolean</type>
		<note>this flag doesn’t actually do anything</note>
      </variable>
      <variable name="maximum_ceiling_height" access="read-only" version="20220115">
    <description>greatest height a platform's ceiling can ever rise</description>
    <type>WU</type>
      </variable>
      <variable name="maximum_floor_height" access="read-only" version="20220115">
    <description>greatest height a platform's floor can ever rise</description>
    <type>WU</type>
      </variable>
      <variable name="minimum_ceiling_height" access="read-only" version="20220115">
    <description>least height a platform's ceiling must rise</description>
    <type>WU</type>
      </variable>
      <variable name="minimum_floor_height" access="read-only" version="20220115">
    <description>least height a platform's floor must rise</description>
    <type>WU</type>
      </variable>
      <variable name="monster_controllable">
		<description>whether platform can be controlled by monsters</description>
		<type>boolean</type>
      </variable>
      <variable name="player_controllable">
		<description>whether platform can be controlled by players</description>
		<type>boolean</type>
      </variable>
      <variable name="polygon" access="read-only">
		<description>polygon of this platform</description>
		<type>polygon</type>
      </variable>
	  <variable name="reverses_direction_when_obstructed" version="20210408">
		<description>platform reverses direction when obstructed</description>
		<type>boolean</type>
	  </variable>
      <variable name="secret" version="20100118">
		<description>platform is secret</description>
		<type>boolean</type>
		<note>secret platforms aren’t shown on the overhead map</note>
      </variable>
      <variable name="speed">
		<description>platform speed</description>
		<type>speed</type>
      </variable>
	  <variable name="tag" version="20221126">
		<description>tag of platform</description>
		<type>tag</type>
	  </variable>
      <variable name="type" version="20100118">
		<description>type of this platform</description>
		<type>platform_type</type>
		<note>the only thing the engine uses type for is the platform’s sound</note>
      </variable>
	  <variable name="uses_native_polygon_heights" version="20210408" access="read-only">
		<description>uses native polygon heights during automatic min,max calculation</description>
		<type>boolean</type>
	  </variable>
    </table>
    <table name="player">
      <function name="accelerate">
		<description>accelerates player</description>
		<argument name="direction"><type>angle</type></argument>
		<argument name="velocity"><type>speed</type></argument>
		<argument name="vertical_velocity"><type>speed</type></argument>
      </function>
      <subtable name="action_flags" classname="lua_action_flags">
		<note>only valid when read/written in idle()</note>
		<note>disabled when the player is viewing a terminal</note>
		<note>latched action flags are only true the first tick the key is held down</note>
		<variable name="action_trigger">
		  <description>respawns, or activates platforms/doors/control panels</description>
		  <type>boolean</type>
		  <note>latched</note>
		</variable>
		<variable name="aux_trigger" version="20231125">
		  <description>formerly microphone button; now dedicated to Lua scripts</description>
		  <type>boolean</type>
		</variable>
		<variable name="cycle_weapons_forward">
		  <description>switches to next weapon</description>
		  <type>boolean</type>
		  <note>latched</note>
		</variable>
		<variable name="cycle_weapons_backward">
		  <description>switches to previous weapon</description>
		  <type>boolean</type>
		  <note>latched</note>
		</variable>
		<variable name="left_trigger">
		  <description>fires primary trigger</description>
		  <type>boolean</type>
		</variable>
		<variable name="right_trigger">
		  <description>fires secondary trigger</description>
		  <type>boolean</type>
		</variable>
		<variable name="toggle_map">
		  <description>toggles the overhead map</description>
		  <type>boolean</type>
		  <note>latched</note>
		</variable>
      </subtable>
      <function name="activate_terminal">
		<description>activates terminal</description>
		<argument name="terminal"><type>terminal</type></argument>
      </function>
      <variable name="color">
		<description>color of player (shirt color, if teams are enabled)</description>
		<type>number</type>
      </variable>
      <subtable name="compass" classname="player_compass">
		<function name="all_off">
		  <description>turns all compass quadrants off, disables beacon</description>
		</function>
		<function name="all_on">
		  <description>turns all compass quadrants on, disables beacon</description>
		</function>
		<variable name="beacon">
		  <description>whether to use the beacon</description>
		  <type>boolean</type>
		</variable>
		<variable name="lua">
		  <description>whether Lua is controlling the compass</description>
		  <type>boolean</type>
		</variable>
		<variable name="ne">
		  <alias>northeast</alias>
		  <description>whether north east compass quadrant is active</description>
		  <type>boolean</type>
		</variable>
		<variable name="nw">
		  <alias>northwest</alias>
		  <description>whether north west compass quadrant is active</description>
		  <type>boolean</type>
		</variable>
		<variable name="se">
		  <alias>southeast</alias>
		  <description>whether south east compass quadrant is active</description>
		  <type>boolean</type>
		</variable>
		<variable name="sw">
		  <alias>southwest</alias>
		  <description>whether south west compass quadrant is active</description>
		  <type>boolean</type>
		</variable>
		<variable name="x">
		  <description>beacon location</description>
		  <type>WU</type>
		</variable>
		<variable name="y">
		  <description>beacon location</description>
		  <type>WU</type>
		</variable>
      </subtable>
      <subtable name="crosshairs" classname="crosshairs">
		<variable name="active" access="local-player">
		  <description>whether crosshairs are visible</description>
		  <type>boolean</type>
		  <note>if you wish to stop the user from toggling the crosshairs, you must set the state every tick</note>
		</variable>
      </subtable>
      <function name="damage">
		<description>inflicts damage on player</description>
		<argument name="amount"><type>number</type></argument>
		<argument name="type" required="false">
		  <description>if unspecified, crush damage is delt</description>
		<type>damage_type</type></argument>
      </function>
      <variable name="dead" access="read-only">
		<description>whether player is dead</description>
		<type>boolean</type>
      </variable>
      <variable name="deaths">
		<description>deaths not caused by players</description>
		<type>number</type>
      </variable>
      <variable name="direction">
		<alias>yaw</alias>
		<description>direction player is facing</description>
		<note>this is the direction in which this player will run; for their aim, use .head_direction</note>
		<type>angle</type>
      </variable>
      <variable name="disconnected">
		<description>whether player dropped out of the game</description>
		<type>boolean</type>
      </variable>
      <variable name="energy">
		<alias>life</alias>
		<description>amount of suit energy player has (150 is normal red health)</description>
		<type>number</type>
      </variable>
      <variable name="elevation">
		<alias>pitch</alias>
		<description>angle player is looking up or down</description>
		<type>angle</type>
      </variable>
      <subtable name="external_velocity" classname="external_velocity">
		<variable name="i">
		  <alias>x</alias>
		  <type>speed</type>
		</variable>
		<variable name="j">
		  <alias>y</alias>
		  <type>speed</type>
		</variable>
		<variable name="k">
		  <alias>z</alias>
		  <type>speed</type>
		</variable>
      </subtable>
      <variable name="extravision_duration">
		<description>extravision time remaining</description>
		<type>time</type>
      </variable>
      <variable name="feet_below_media" access="read-only">
		<description>whether player is standing in liquid</description>
		<type>boolean</type>
      </variable>
      <function name="fade_screen" access="local-player">
		<description>fades player’s screen</description>
		<argument name="type"><type>fade_type</type></argument>
      </function>
      <function name="find_action_key_target" return="variant">
		<description>if player is in range of a platform or control panel, returns a platform or side; otherwise returns nil</description>
		<return><type>variant</type></return>
		
		<note>you can check the type of the return with is_polygon() and is_side()</note>
      </function>
      <function name="find_target" return="variant">
		<description>returns t, x, y, z, polygon, where t is the side, polygon_floor, polygon_ceiling, monster, scenery, or polygon (if the target is the surface of a liquid, and penetrate_media is false) the player is looking at; and x, y, z, and polygon are the point the player is looking at</description>
		<argument name="penetrate_media" required="false" version="20220115"><type>boolean</type></argument>
		<return><type>variant</type></return>
		<return><type>WU</type></return>
		<return><type>WU</type></return>
		<return><type>WU</type></return>
		<return><type>polygon</type></return>
		<note>you can check the type of t with is_side(), is_polygon_floor(), is_polygon_ceiling(), is_monster(), is_scenery(), and is_polygon()</note>
		<note>this function will not work under liquid unless penetrate_media is true</note>
      </function>
	  <variable name="has_map_open" access="read-only" version="20220115">
		<description>whether player has overhead map open</description>
	  </variable>
      <variable name="head_below_media" access="read-only">
		<description>whether player is completely below liquid</description>
		<type>boolean</type>
      </variable>
      <variable name="head_direction" version="20200830">
        <description>direction in which player is looking</description>
        <note>while glancing, this differs from .direction</note>
      </variable>
	  <variable name="hotkey" version="20210408">
		<note>only valid when read/written in idle()</note>
		<note>hotkeys aren’t latched, and can only be transmitted every 3 ticks</note>
		<note>to check for a continously pressed hotkey, or to implement your own latch, count down from 2 before checking it again</note>
		<note>hotkeys override cycle weapon backward/forward; these flags will be false for 3 ticks after a hotkey is pressed</note>
		<description>pressed hotkey, from 1-12, or 0 for no hotkey</description>
		<type>number</type>
	  </variable>
	  <subtable-accessor name="hotkey_bindings" classname="hotkey_bindings" index="n" version="20210408" access="local-player">
		<description>keys or buttons the player has bound to hotkeys 1-12</description>
		<variable name="joystick" access="read-only">
		  <description>joystick button binding</description>
		  <type>string</type>
		</variable>
		<variable name="key" access="read-only">
		  <description>key binding</description>
		  <type>string</type>
		</variable>
		<variable name="mouse" access="read-only">
		  <description>mouse button binding</description>
		  <type>string</type>
		</variable>
	  </subtable-accessor>
      <variable name="infravision_duration">
		<description>infravision time remaining</description>
		<type>time</type>
      </variable>
      <subtable name="internal_velocity" classname="internal_velocity">
		<variable name="forward" access="read-only">
		  <description>player’s forward velocity</description>
		  <type>number</type>
		</variable>
		<variable name="perpendicular" access="read-only">
		  <description>player’s perpendicular (sidestep) velocity</description>
		  <type>number</type>
		</variable>
      </subtable>
      <variable name="invincibility_duration">
		<description>invincibility time remaining</description>
		<type>time</type>
      </variable>
      <variable name="invisibility_duration">
		<description>invisibility time remaining</description>
		<type>time</type>
		<note>player will become subtly invisible if this is set higher than the standard invisibility duration (70 seconds)</note>
      </variable>
      <function-variable name="items">
		<description>how many of item the player is carrying</description>
		<argument name="item_type"><type>item_type</type></argument>
		<type>number</type>
      </function-variable>
      <variable name="local_" access="read-only">
		<description>true if this player is the local player</description>
		<type>boolean</type>
		<note>normally, you shouldn’t need this--you’ll just make the game go out of sync</note>
      </variable>
      <function-variable name="kills">
		<description>kill count against slain_player</description>
		<argument name="slain_player"><type>player</type></argument>
		<type>number</type>
      </function-variable>
      <variable name="monster" access="read-only">
		<description>monster that corresponds to player</description>
		<type>monster</type>
      </variable>
      <variable name="motion_sensor_active" access="local-player">
		<description>whether player can view his motion sensor</description>
		<type>boolean</type>
		<note>currently, this also controls compass visibility</note>
      </variable>
      <variable name="name" access="read-only">
		<description>player’s name</description>
		<type>string</type>
      </variable>
      <variable name="oxygen">
		<description>amount of oxygen player has (max is 10800)</description>
		<type>number</type>
      </variable>
      <subtable-accessor name="overlays" classname="overlays" index="n">
		<description>there are 6 overlays, numbered 0 through 5</description>
		<function name="clear" access="local-player">
		  <description>turns off overlay</description>
		</function>
		<variable name="color" access="write-only">
		  <description>text color</description>
		  <type>number</type>
		</variable>
		<function name="fill_icon" access="local-player">
		  <description>fills icon with solid color</description>
		  <argument name="color"><type>number</type></argument>
		</function>
		<variable name="icon" access="write-only">
		  <description>icon</description>
		  <type>icon</type>
		</variable>
		<variable name="text" access="write-only">
		  <description>text</description>
		  <type>string</type>
		</variable>
      </subtable-accessor>
      <function name="play_sound" access="local-player">
		<description>plays sound that only player can hear</description>
		<argument name="sound"><type>sound</type></argument>
		<argument name="pitch"><type>scale</type></argument>
		<note>if you want all players to hear the sound as if it is coming from this player, use .monster:play_sound() instead</note>
      </function>
      <variable name="points">
		<description>how many points player has</description>
		<type>number</type>
      </variable>
      <variable name="polygon" access="read-only">
		<description>polygon the player is standing on</description>
		<type>polygon</type>
		<note>if this gives you trouble, try .monster.polygon</note>
      </variable>
      <function name="position">
		<description>set player position</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
      </function>
      <function name="print">
		<description>prints message to player’s screen</description>
		<argument name="message"><type>string</type></argument>
      </function>
	  <function name="revive" version="20210408">
		<description>revives player</description>
		<note>player must be totally dead</note>
	  </function>
      <variable name="team">
		<description>player’s team (pants color)</description>
		<type>number</type>
      </variable>
      <function name="teleport">
		<description>teleports player to polygon</description>
		<argument name="polygon"><type>WU</type></argument>
      </function>
      <function name="teleport_to_level">
		<description>teleports player to level (of course, all the other players will also go to that level)</description>
		<argument name="level"><type>number</type></argument>
      </function>
	  <variable name="teleporting" access="read-only" version="20220115">
		<description>whether player is teleporting</description>
	  </variable>
      <subtable name="texture_palette">
		<description>displays a texture palette instead of the classic HUD</description>
		<variable name="highlight" access="local-player">
		  <description>number of slot to highlight</description>
		  <note>can be nil</note>
		</variable>
		<variable name="size" access="local-player">
		  <description>how many slots the palette has</description>
		  <type>number</type>
		  <note>there is a maximum of 256 slots</note>
		  <note>the texture palette is visible whenever the size is greater than 0</note>
		  <note>rows/columns may change in the future based on the user’s screen layout prefs</note>
		</variable>
		<subtable-accessor name="slots" classname="texture_palette_slots" index="n">
		  <variable name="texture_index" access="local-player">
			<description>texture index of this slot</description>
			<type>number</type>
		  </variable>
		  <variable name="collection" access="local-player">
			<description>collection of this slot</description>
			<type>collection</type>
		  </variable>
		  <variable name="type" access="local-player" version="20090909">
			<description>texture type of this slot such as wall or sprite; see "Texture Types"</description>
			<type>texture_type</type>
		  </variable>
		  <function name="clear">
			<description>makes this slot empty</description>
		  </function>
		</subtable-accessor>
      </subtable>
	  <variable name="totally_dead" version="20210408" access="read-only">
		<description>the player is dead and the death animation has finished</description>
	  </variable>
      <function name="view_player" version="20080707">
		<description>switch to another player’s view</description>
		<argument name="player"><type>player</type></argument>
      </function>
      <variable name="viewed_player" access="local-player read-only" version="20200830">
        <description>the player currently being viewed by the local player</description>
        <type>player</type>
      </variable>
      <subtable name="weapons">
		<variable name="current" access="read-only">
		  <description>weapon the player is currently wielding</description>
		  <type>player_weapon</type>
		  <note>can be nil</note>
		</variable>
		<variable name="desired" access="read-only" version="20090909">
		  <description>weapon the player wants to switch to</description>
		  <type>player_weapon</type>
		  <note>can be nil</note>
		</variable>
		<variable name="active" version="20080707">
		  <description>when a player’s weapons are not active, he does not see weapons in hand, and can not fire</description>
		  <type>boolean</type>
		</variable>
      </subtable>
      <subtable-accessor name="weapons" classname="player_weapon" index="weapon_type">
		<subtable name="primary" classname="player_weapon_trigger">
		  <alias>secondary</alias>
		  <variable name="rounds" access="read-only">
			<description>how many rounds are currently loaded into the weapon</description>
			<type>number</type>
		  </variable>
		</subtable>
		<function name="select">
		  <description>attempts to force player to ready weapon</description>
		</function>
		<variable name="type" access="read-only">
		  <description>type of this weapon</description>
		  <type>weapon_type</type>
		</variable>
      </subtable-accessor>
      <variable name="x" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="zoom_active" access="local-player">
		<description>whether player’s sniper zoom is active</description>
		<type>boolean</type>
      </variable>
    </table>
    <table name="player_start">
      <variable name="facing" access="read-only" version="20111201">
		<description>player starting location facing</description>
		<type>angle</type>
      </variable>
      <variable name="from_ceiling" access="read-only" version="20111201">
		<description>whether player starting location z is from ceiling</description>
		<type>boolean</type>
      </variable>
      <variable name="polygon" access="read-only" version="20111201">
		<description>polygon player starting location is in</description>
		<type>polygon</type>
      </variable>
      <variable name="team" access="read-only" version="20111201">
		<description>which team starts at this player starting location</description>
		<type>player_color</type>
      </variable>
      <variable name="x" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only" version="20111201">
		<type>WU</type>
		<note>from floor or ceiling</note>
      </variable>
    </table>
    <table name="polygon">
      <subtable-accessor name="adjacent_polygons" classname="adjacent_polygons" index="n">
		<description>returns adjacent polygon n (across from line n), if one exists, or nil</description>
      </subtable-accessor>
      <function name="adjacent_polygons">
		<description>iterates through all polygons directly adjacent to this polygon</description>
      </function>
      <variable name="area" access="read-only">
		<description>the area of this polygon</description>
		<type>square WU</type>
      </variable>
      <subtable name="ceiling" classname="polygon_ceiling">
		<alias>floor</alias>
		<variable name="collection">
		  <description>texture collection</description>
		  <type>collection</type>
		</variable>
		<variable name="height">
		  <alias>z</alias>
		  <description>height</description>
		  <type>WU</type>
		</variable>
		<variable name="light">
		  <description>texture light</description>
		  <type>light</type>
		</variable>
		<variable name="texture_index">
		  <description>texture bitmap index</description>
		  <type>number</type>
		</variable>
		<variable name="texture_x">
		  <description>texture x offset</description>
		  <type>WU</type>
		</variable>
		<variable name="texture_y">
		  <description>texture y offset</description>
		  <type>WU</type>
		</variable>
		<variable name="transfer_mode">
		  <description>texture transfer mode</description>
		  <type>transfer_mode</type>
		</variable>
      </subtable>
	  <function name="change_height" version="20210408">
		<description>changes polygon floor and ceiling heights, if possible</description>
		<argument name="floor"><type>WU</type></argument>
		<argument name="ceiling"><type>WU</type></argument>
		<return><type>boolean</type></return>
		<note>won’t squish monsters; returns false instead</note>
		<note>this is much less optimized than moving a platform</note>
		<note>you may need to create sides if you are raising/lowering what used to be a flat floor/ceiling</note>
	  </function>
	  <function name="check_collision" version="20210408">
		<argument name="x0"><type>WU</type></argument>
		<argument name="y0"><type>WU</type></argument>
		<argument name="z0"><type>WU</type></argument>
		<argument name="owner"><type>monster</type></argument>
		<argument name="x1"><type>WU</type></argument>
		<argument name="y1"><type>WU</type></argument>
		<argument name="z1"><type>WU</type></argument>
		<argument name="include_objects" required="false"><type>boolean</type></argument>
		<argument name="include_media" required="false"><type>boolean</type></argument>
		<description>returns t, x, y, z, polygon, where t is nil (if there was no collision), or the side, polygon_floor, polygon_ceiling, monster, scenery, or polygon (if the collision is with the surface of a liquid) where the line segment collided with the map (or object or media); and x, y, z, polygon is the location of the collision, or the end point if there was no collision</description>
		<return><type>variant</type></return>
		<return><type>WU</type></return>
		<return><type>WU</type></return>
		<return><type>WU</type></return>
		<return><type>polygon</type></return>
		<note>the owner is a monster or player to ignore, or nil</note>
		<note>you can check the type of t with is_side(), is_polygon_floor(), is_polygon_ceiling(), is_monster(), is_scenery(), and is_polygon()</note>
		<note>in order of descending speed: find_polygon(), check_collision() without objects, check_collision() including objects</note>
	  </function>
      <function name="contains">
		<description>whether the point is in this polygon</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z" required="false"><type>WU</type></argument>
      </function>
      <subtable-accessor name="endpoints" classname="polygon_endpoints" index="n">
		<description>returns endpoint n</description>
      </subtable-accessor>
      <function name="endpoints">
		<description>iterates through all of this polygon’s endpoints</description>
      </function>
	  <function name="find_polygon" version="20210408">
		<description>traverses map from (x1, y1) and returns polygon containing (x2, y2)</description>
		<argument name="x1"><type>WU</type></argument>
		<argument name="y1"><type>WU</type></argument>
		<argument name="x2"><type>WU</type></argument>
		<argument name="y2"><type>WU</type></argument>
		<note>can be nil if there is no direct route between the two points, or the destination point is not in any polygon</note>
		<note>ignores floor/ceiling height</note>
	  </function>
      <function name="find_line_crossed_leaving" version="20080707">
		<description>returns the polygon line crossed by line segment (x1, y1) (x2, y2)</description>
		<argument name="x1"><type>WU</type></argument>
		<argument name="y1"><type>WU</type></argument>
		<argument name="x2"><type>WU</type></argument>
		<argument name="y2"><type>WU</type></argument>
		<note>can be nil if the line segment doesn’t intersect a polygon line</note>
      </function>
      <subtable-accessor name="lines" classname="polygon_lines" index="n">
		<description>returns polygon line n</description>
      </subtable-accessor>
      <function name="lines">
		<description>iterates through all of this polygon’s lines</description>
      </function>
      <variable name="media">
		<description>polygon media (liquid)</description>
		<type>media</type>
      </variable>
      <function name="monsters">
		<description>iterates through all monsters in this polygon (including player monsters)</description>
      </function>
      <variable name="permutation">
		<description>raw permutation index of this polygon</description>
		<type>number</type>
      </variable>
      <function name="play_sound">
		<description>plays sound in center of polygon on floor</description>
		<argument name="sound"><type>sound</type></argument>
      </function>
      <function name="play_sound">
		<description>plays sound at location</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="sound"><type>sound</type></argument>
		<argument name="pitch" required="false"><type>number</type></argument>
		<note>if you want to play a sound at an object location, use that object’s play_sound function instead</note>
      </function>
      <subtable-accessor name="sides" classname="polygon_sides" index="n">
		<description>returns polygon side n if it exists</description>
      </subtable-accessor>
      <function name="sides">
		<description>iterates through all of this polygon’s sides</description>
      </function>
      <variable name="type">
		<description>polygon type</description>
		<type>polygon_type</type>
      </variable>
      <variable name="visible_on_automap" version="20150619">
		<description>whether polygon is revealed on local player’s automap</description>
		<type>boolean</type>
      </variable>
      <variable name="x" access="read-only">
		<description>center of polygon</description>
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<description>center of polygon</description>
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only">
		<description>shortcut for .floor.height</description>
		<type>WU</type>
      </variable>
    </table>
    <table name="projectile">
      <function name="delete" version="20111201">
		<description>removes projectile from the map</description>
      </function>
      <variable name="damage_scale">
		<description>amount to scale projectile’s normal damage by upon detonating</description>
		<type>scale</type>
      </variable>
      <variable name="dz">
		<description>instantaneous downward velocity</description>
		<type>speed</type>
      </variable>
      <variable name="elevation">
		<alias>pitch</alias>
		<description>vertical angle</description>
		<type>angle</type>
      </variable>
      <variable name="facing">
		<alias>yaw</alias>
		<description>direction</description>
		<type>angle</type>
      </variable>
      <function name="play_sound">
		<description>plays sound coming from this projectile</description>
		<argument name="sound"><type>sound</type></argument>
      </function>
      <function name="position">
		<description>sets projectile position</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
      </function>
      <variable name="owner">
		<description>monster that fired projectile, or nil</description>
		<type>monster</type>
      </variable>
      <variable name="polygon" access="read-only">
		<description>polygon the projectile is in</description>
		<type>polygon</type>
      </variable>
      <variable name="target">
		<description>target of guided projectile, or nil</description>
		<type>monster</type>
      </variable>
      <variable name="type" access="read-only">
		<description>type of projectile</description>
		<type>projectile_type</type>
      </variable>
      <variable name="x" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only">
		<type>WU</type>
      </variable>
    </table>
    <table name="scenery">
      <function name="damage">
		<description>damages scenery</description>
      </function>
      <variable name="damaged" access="read-only">
		<description>whether this scenery has been damaged</description>
		<type>boolean</type>
      </variable>
      <function name="delete">
		<description>removes scenery from the map</description>
      </function>
      <variable name="facing">
		<description>direction scenery is facing</description>
		<type>angle</type>
      </variable>
      <function name="play_sound">
		<description>play sound coming from this scenery</description>
		<argument name="sound"><type>sound</type></argument>
      </function>
      <variable name="polygon" access="read-only">
		<description>polygon the scenery is in</description>
		<type>polygon</type>
      </variable>
      <function name="position" version="20090909">
		<description>sets position of scenery</description>
		<argument name="x">
		<type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
      </function>
      <variable name="solid">
		<description>whether this scenery is solid</description>
		<type>boolean</type>
      </variable>
	  <function name="teleport_in" version="20240712">
		<description>teleports scenery in</description>
		<note>can fail silently if there are not enough effects slots</note>
	  </function>
	  <function name="teleport_out" version="20240712">
		<description>teleports scenery out</description>
		<note>can fail silently if there are not enough effects slots</note>
	  </function>
      <variable name="type" access="read-only">
		<description>type of scenery</description>
		<type>scenery_type</type>
      </variable>
	  <variable name="visible" version="20240712">
		<description>whether this scenery is visible</description>
		<type>boolean</type>
	  </variable>
      <variable name="x" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only">
		<type>WU</type>
      </variable>
    </table>
    <table name="side">
	  <variable name="ambient_delta" version="20210408">
		<description>constant offset from calculated light intensity</description>
	  </variable>
      <subtable name="control_panel" classname="side_control_panel">
		<variable name="can_be_destroyed" version="20080707">
		  <description>whether projectiles destroy this switch</description>
		  <type>boolean</type>
		</variable>
		<variable name="light_dependent" version="20080707">
		  <description>switch can only be activated if light > 75%</description>
		  <type>boolean</type>
		</variable>
		<variable name="only_toggled_by_weapons" version="20080707">
		  <description>switch can only be toggled by weapons</description>
		  <type>boolean</type>
		</variable>
		<variable name="repair" version="20080707">
		  <description>switch is a repair switch</description>
		  <type>boolean</type>
		</variable>
		<variable name="status" version="20080707">
		  <description>switch is active</description>
		  <type>boolean</type>
		</variable>
		<variable name="type" version="20080707">
		  <description>type of control panel</description>
		  <type>control_panel_type</type>
		</variable>
		<variable name="permutation">
		  <description>permutation of control panel</description>
		  <type>number</type>
		</variable>
		<variable name="uses_item" access="read-only" version="20111201">
		  <description>i.e. chip insertion</description>
		  <type>boolean</type>
		</variable>
		<note>nil if the side is not a control panel</note>
		<note version="20080707">set to true or false to create/destroy a control panel</note>
      </subtable>
      <subtable name="primary" classname="primary_side">
		<alias>secondary</alias>
		<alias>transparent</alias>
		<variable name="collection">
		  <description>texture collection</description>
		  <type>collection</type>
		</variable>
		<variable name="empty">
		  <description>whether side is empty</description>
		  <type>boolean</type>
		  <note version="Git">transparent sides only in earlier versions</note>
		  <note>setting empty to false is a no-op; set collection and texture_index instead</note>
		</variable>
		<variable name="light">
		  <description>texture light</description>
		  <type>light</type>
		</variable>
		<variable name="texture_index">
		  <description>texture bitmap index</description>
		  <type>number</type>
		</variable>
		<variable name="texture_x">
		  <description>texture x offset</description>
		  <type>WU</type>
		</variable>
		<variable name="texture_y">
		  <description>texture y offset</description>
		  <type>WU</type>
		</variable>
		<variable name="transfer_mode">
		  <description>texture transfer mode</description>
		  <type>transfer_mode</type>
		</variable>
      </subtable>
      <function name="play_sound">
		<description>play sound coming from this side</description>
		<argument name="sound"><type>sound</type></argument>
		<argument name="pitch" required="false"><type>number</type></argument>
      </function>
      <variable name="line" access="read-only">
		<description>line this side is attached to</description>
		<type>line</type>
      </variable>
      <variable name="polygon" access="read-only">
		<description>polygon this side is attached to</description>
		<type>polygon</type>
      </variable>
      <function name="recalculate_type" version="20081213">
		<description>correct the side type (Forge can generate incorrect side types)</description>
      </function>
      <variable name="type" access="read-only" version="20080707">
		<description>type of side</description>
      </variable>
    </table>
    <table name="sound_object">
      <variable name="from_ceiling" access="read-only" version="20111201">
		<description>whether sound object location z is from ceiling</description>
		<type>boolean</type>
      </variable>
      <variable name="light" access="read-only" version="20111201">
		<description>if sound object uses a light for volume, the light it uses</description>
		<type>light</type>
		<note>can be nil if sound object doesn’t use light for volume</note>
      </variable>
      <variable name="on_platform" access="read-only" version="20111201">
		<description>whether sound object is a platform sound</description>
		<type>boolean</type>
      </variable>
      <variable name="polygon" access="read-only" version="20111201">
		<description>sound object polygon</description>
		<type>polygon</type>
      </variable>
      <variable name="type" access="read-only" version="20111201">
		<description>type of sound object</description>
		<type>ambient_sound</type>
      </variable>
      <variable name="volume" access="read-only" version="20111201">
		<description>volume of sound object from 0.0 to 1.0</description>
		<type>number</type>
		<note>can be nil if sound object uses light for volume</note>
      </variable>
      <variable name="x" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="y" access="read-only" version="20111201">
		<type>WU</type>
      </variable>
      <variable name="z" access="read-only" version="20111201">
		<type>WU</type>
		<note>from floor or ceiling</note>
      </variable>
    </table>
    <table name="tag">
      <variable name="active">
		<description>tag is active</description>
		<type>boolean</type>
      </variable>
    </table>
    <table name="terminal">
    </table>
    <accessor name="Annotations" contains="annotation">
      <length>
		<description>number of map annotations</description>
      </length>
      <index />
      <call>
		<description>iterates through all annotations</description>
      </call>
      <function name="new">
		<description>returns a new annotation</description>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="text"><type>string</type></argument>
		<argument name="x" required="false"><type>WU</type></argument>
		<argument name="y" required="false"><type>WU</type></argument>
      </function>
    </accessor>
    <accessor name="Cameras" contains="camera">
      <length>
		<description>number of cameras</description>
      </length>
      <index/>
      <call>
		<description>iterates through all cameras</description>
      </call>
      <function name="new">
		<description>returns a new uninitialized camera</description>
		<note>make sure to add path points and angles before activating the camera</note>
      </function>
    </accessor>
    <accessor name="Effects" contains="effect">
      <length>
		<description>maximum number of effects</description>
      </length>
      <index/>
      <call>
		<description>iterates through all valid effects</description>
      </call>
      <function name="new" version="20111201">
		<description>returns a new effect</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="height"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="type"><type>effect_type</type></argument>
		<return><type>effect</type></return>
      </function>
    </accessor>
    <accessor name="Endpoints" contains="endpoint">
      <length>
		<description>number of endpoints in level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all endpoints in the level</description>
      </call>
    </accessor>
	<accessor name="Ephemera" contains="ephemera" version="20210408">
	  <description>
		<p>Ephemera are a render-only version of Effects. They were designed to be a lightweight way to add effects such as precipitation or decals. They do not use any global random functionality, and they don’t interact at all with other objects in the world, so they are safe to turn on and off without affecting net game sync and film playback (see <a href="#sync">"Net Games and Films"</a>).</p>
		<p>Ephemera are not saved or restored in saved games, so it is up to the Lua script to serialize them and persist them if desired; and to recreate them upon resume. Likewise, ephemera custom fields are not saved/restored using <code>Level.restored_saved()</code></p>
		<p><em>All</em> ephemera functions are "local player"</p>
	  </description>
	  <length>
		<description>maximum number of ephemera</description>
	  </length>
	  <call>
		<description>iterates through all valid ephemera</description>
	  </call>
	  <function name="new">
		<description>returns a new ephemera</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="collection"><type>collection</type></argument>
		<argument name="sequence"><type>shape</type></argument>
		<argument name="facing"><type>angle</type></argument>
		<return><type>ephemera</type></return>
	  </function>
	  <variable name="quality" access="read-only">
		<type>ephemera_quality</type>
		<description>user’s ephemera quality setting</description>
		<note>it is up to the script’s discretion how many ephemera to create / maintain, based on this quality setting; if set to off, ephemera are not rendered regardless of how many the script creates</note>
	  </variable>
	  <index/>
	</accessor>
    <accessor name="Game" contains="game"/>
    <accessor name="Goals" contains="goal">
      <length>
		<description>number of saved map objects (of all types)</description>
      </length>
      <index/>
      <call>
		<description>iterates through all goals</description>
      </call>
    </accessor>
    <accessor name="Items" contains="item">
      <length>
		<description>maximum number of map objects</description>
      </length>
      <index/>
      <call>
		<description>iterates through all valid items</description>
      </call>
      <function name="new">
		<description>returns a new item</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="height"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="type"><type>item_type</type></argument>
		<return><type>item</type></return>
      </function>
    </accessor>
    <accessor name="ItemStarts" contains="item_start">
      <length>
		<description>number of map objects in the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all item starting locations in the level</description>
      </call>
    </accessor>
    <accessor name="Level" contains="level">
    </accessor>
    <accessor name="Lines" contains="line">
      <length>
		<description>number of lines in level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all lines in the level</description>
      </call>
    </accessor>
    <accessor name="Lights" contains="light">
      <length>
		<description>number of lights in level</description>
      </length>
      <index />
      <call>
		<description>iterates through all lights in the level</description>
      </call>
      <function name="new">
		<description>returns a new light</description>
		<argument name="light_preset" required="false"><type>light_preset</type></argument>
      </function>
    </accessor>
    <accessor name="Media" contains="media">
      <length>
		<description>number of media (liquids) on the level</description>
      </length>
      <index />
      <call>
		<description>iterates through all media on the level</description>
      </call>
	  <function name="new" version="20210408">
		<description>returns a new liquid</description>
	  </function>
    </accessor>
    <accessor name="Monsters" contains="monster">
      <length>
		<description>maximum number of monsters</description>
      </length>
      <index/>
      <call>
		<description>iterates through all valid monsters (including player monsters)</description>
      </call>
      <function name="new">
		<description>returns a new monster</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="height"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="type"><type>monster_type</type></argument>
		<return><type>monster</type></return>
      </function>
    </accessor>
    <accessor name="MonsterStarts" contains="monster_start">
      <length>
		<description>number of map objects in the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all monster starting locations in the level</description>
      </call>
    </accessor>
    <accessor name="Music" contains="music">
      <length>
		<description>maximum number of music channels active simultaneously</description>
      </length>
      <index/>
      <call>
		<description>iterates through all the music channels</description>
      </call>
	  <function name="new" version="20231125">
		<description>returns a new music channel</description>
		<argument name="track"><type>string</type></argument>
		<argument name="volume" required="false"><type>number</type></argument>
		<argument name="loop" required="false"><type>boolean</type></argument>
		<return><type>music</type></return>
		<note>volume is decimal [0 - 1] and is 1 if not specified</note>
		<note>loop is enabled by default</note>
	  </function>
	  <function name="clear">
		<description>clears the level playlist</description>
      </function>
      <function name="fade">
		<description>fades out the currently playing track and clears the playlist</description>
		<argument name="duration"><type>seconds</type></argument>
      </function>
      <function name="play">
		<description>appends all of the specified tracks to the end of the playlist</description>
		<argument name="track1"><type>string</type></argument>
		<argument name="track2" required="false"><type>string</type></argument>
		<argument name="..." required="false"><type>string</type></argument>
      </function>
      <function name="stop">
		<description>stops level music and clears the playlist</description>
      </function>
      <function name="valid">
		<description>for every track passed, return true if it exists and is playable and false otherwise</description>
		<argument name="track1"><type>string</type></argument>
		<argument name="track2" required="false"><type>string</type></argument>
		<argument name="..." required="false"><type>string</type></argument>
      </function>
    </accessor>
    <accessor name="Platforms" contains="platform">
      <length>
		<description>number of platforms on the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all platforms in the level</description>
      </call>
    </accessor>
    <accessor name="Players" contains="player">
      <length>
		<description>number of players in the game</description>
      </length>
      <index/>
      <call>
		<description>iterates through all players in the game</description>
      </call>
      <function name="print">
		<description>prints message to all players’ screens</description>
		<argument name="message"><type>string</type></argument>
      </function>
      <variable name="local_player" version="20200830" access="read-only">
		<description>the local player</description>
		<type>Player</type>
		<note>normally, you shouldn’t need this--you’ll just make the game go out of sync</note>
      </variable>
    </accessor>
    <accessor name="PlayerStarts" contains="player_start">
      <length>
		<description>number of map objects in the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all player starting locations in the level</description>
      </call>
    </accessor>
    <accessor name="Polygons" contains="polygon">
      <length>
		<description>number of polygons in the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all polygons in the level</description>
      </call>
    </accessor>
    <accessor name="Projectiles" contains="projectile">
      <length>
		<description>maximum number of projectiles</description>
      </length>
      <index/>
      <call>
		<description>iterates through all valid projectiles</description>
      </call>
      <function name="new">
		<description>returns a new projectile</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="z"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="type"><type>projectile_type</type></argument>
		<note>remember to set the projectile’s elevation, facing and owner immediately after you’ve created it</note>
      </function>
    </accessor>
    <accessor name="Scenery" contains="scenery">
      <length>
		<description>maximum number of map objects</description>
      </length>
      <index/>
      <call>
		<description>iterates through all valid scenery</description>
      </call>
      <function name="new">
		<description>returns a new scenery</description>
		<argument name="x"><type>WU</type></argument>
		<argument name="y"><type>WU</type></argument>
		<argument name="height"><type>WU</type></argument>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="type"><type>scenery_type</type></argument>
		<return><type>scenery</type></return>
      </function>
    </accessor>
    <accessor name="Sides" contains="side">
      <length>
		<description>number of sides on the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all sides on the level</description>
      </call>
      <function name="new" version="20080707">
		<description>creates a new side</description>
		<argument name="polygon"><type>polygon</type></argument>
		<argument name="line"><type>line</type></argument>
		<return><type>side</type></return>
		<note>side must not already exist</note>
      </function>
    </accessor>
    <accessor name="SoundObjects" contains="sound_object">
      <length>
		<description>number of map objects in the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all sound objects in the level</description>
      </call>
    </accessor>
    <accessor name="Tags" contains="tag">
      <index/>
    </accessor>
    <accessor name="Terminals" contains="terminal">
      <length>
		<description>number of terminal texts in the level</description>
      </length>
      <index/>
      <call>
		<description>iterates through all terminal texts on the level</description>
      </call>
    </accessor>
    <enum name="ambient_sound">
      <mnemonics>
		<mnemonic name="water"/>
		<mnemonic name="sewage"/>
		<mnemonic name="lava"/>
		<mnemonic name="goo"/>
		<mnemonic name="underwater"/>
		<mnemonic name="wind"/>
		<mnemonic name="waterfall"/>
		<mnemonic name="siren"/>
		<mnemonic name="fan"/>
		<mnemonic name="spht door"/>
		<mnemonic name="spht platform"/>
		<mnemonic name="heavy spht door"/>
		<mnemonic name="heavy spht platform"/>
		<mnemonic name="light machinery"/>
		<mnemonic name="heavy machinery"/>
		<mnemonic name="transformer"/>
		<mnemonic name="sparking transformer"/>
		<mnemonic name="machine binder"/>
		<mnemonic name="machine bookpress"/>
		<mnemonic name="machine puncher"/>
		<mnemonic name="electric hum"/>
		<mnemonic name="alarm"/>
		<mnemonic name="night wind"/>
		<mnemonic name="pfhor door"/>
		<mnemonic name="pfhor platform"/>
		<mnemonic name="alien noise 1"/>
		<mnemonic name="alien noise 2"/>
		<mnemonic name="alien harmonics"/>
      </mnemonics>
    </enum>
    <enum name="completion_state">
      <mnemonics>
		<mnemonic name="unfinished"/>
		<mnemonic name="finished"/>
		<mnemonic name="failed"/>
      </mnemonics>
    </enum>
    <enum name="collection">
      <variable name="bitmap_count">
		<description>number of bitmaps in collection</description>
      </variable>
      <mnemonics>
		<mnemonic name="interface"/>
		<mnemonic name="weapons in hand"/>
		<mnemonic name="juggernaut"/>
		<mnemonic name="tick"/>
		<mnemonic name="explosions"/>
		<mnemonic name="hunter"/>
		<mnemonic name="player"/>
		<mnemonic name="items"/>
		<mnemonic name="trooper"/>
		<mnemonic name="fighter"/>
		<mnemonic name="defender"/>
		<mnemonic name="yeti"/>
		<mnemonic name="bob"/>
		<mnemonic name="vacbob"/>
		<mnemonic name="enforcer"/>
		<mnemonic name="drone"/>
		<mnemonic name="compiler"/>
		<mnemonic name="water"/>
		<mnemonic name="lava"/>
		<mnemonic name="sewage"/>
		<mnemonic name="jjaro"/>
		<mnemonic name="pfhor"/>
		<mnemonic name="water scenery"/>
		<mnemonic name="lava scenery"/>
		<mnemonic name="sewage scenery"/>
		<mnemonic name="jjaro scenery"/>
		<mnemonic name="pfhor scenery"/>
		<mnemonic name="day"/>
		<mnemonic name="night"/>
		<mnemonic name="moon"/>
		<mnemonic name="space"/>
		<mnemonic name="cyborg"/>
      </mnemonics>
    </enum>
    <enum name="control_panel_class">
      <mnemonics>
		<mnemonic name="oxygen recharger"/>
		<mnemonic name="single shield recharger"/>
		<mnemonic name="double shield recharger"/>
		<mnemonic name="triple shield recharger"/>
		<mnemonic name="light switch"/>
		<mnemonic name="platform switch"/>
		<mnemonic name="tag switch"/>
		<mnemonic name="pattern buffer"/>
		<mnemonic name="terminal"/>
      </mnemonics>
    </enum>
    <enum name="control_panel_type">
      <variable name="active_texture_index" access="read-only" version="20080707">
		<description>bitmap index when control panel is active</description>
		<type>number</type>
      </variable>
      <variable name="class" access="read-only">
		<description>class of this control panel type</description>
		<type>control_panel_class</type>
      </variable>
      <variable name="collection" access="read-only" version="20080707">
		<description>collection this control panel belongs to</description>
		<type>collection</type>
      </variable>
      <variable name="inactive_texture_index" access="read-only" version="20080707">
		<description>bitmap index when control panel is inactive/destroyed</description>
		<type>number</type>
      </variable>
    </enum>
    <enum name="damage_type">
      <mnemonics>
		<mnemonic name="explosion"/>
		<mnemonic name="staff"/>
		<mnemonic name="projectile"/>
		<mnemonic name="absorbed"/>
		<mnemonic name="flame"/>
		<mnemonic name="claws"/>
		<mnemonic name="alien weapon"/>
		<mnemonic name="hulk slap"/>
		<mnemonic name="compiler"/>
		<mnemonic name="fusion"/>
		<mnemonic name="hunter"/>
		<mnemonic name="fists"/>
		<mnemonic name="teleporter"/>
		<mnemonic name="defender"/>
		<mnemonic name="yeti claws"/>
		<mnemonic name="yeti projectile"/>
		<mnemonic name="crushing"/>
		<mnemonic name="lava"/>
		<mnemonic name="suffocation"/>
		<mnemonic name="goo"/>
		<mnemonic name="energy drain"/>
		<mnemonic name="oxygen drain"/>
		<mnemonic name="drone"/>
		<mnemonic name="shotgun"/>
      </mnemonics>
    </enum>
    <enum name="difficulty_type">
      <mnemonics>
		<mnemonic name="kindergarten"/>
		<mnemonic name="easy"/>
		<mnemonic name="normal"/>
		<mnemonic name="major damage"/>
		<mnemonic name="total carnage"/>
      </mnemonics>
    </enum>
    <enum name="scoring_mode">
      <mnemonics>
		<mnemonic name="most points"/>
		<mnemonic name="most time"/>
		<mnemonic name="least points"/>
		<mnemonic name="least time"/>
      </mnemonics>
    </enum>
    <enum name="effect_type">
      <mnemonics>
		<mnemonic name="rocket explosion"/>
		<mnemonic name="rocket contrail"/>
		<mnemonic name="grenade explosion"/>
		<mnemonic name="grenade contrail"/>
		<mnemonic name="bullet ricochet"/>
		<mnemonic name="alien weapon ricochet"/>
		<mnemonic name="flamethrower burst"/>
		<mnemonic name="fighter blood splash"/>
		<mnemonic name="player blood splash"/>
		<mnemonic name="civilian blood splash"/>
		<mnemonic name="assimilated civilian blood splash"/>
		<mnemonic name="enforcer blood splash"/>
		<mnemonic name="compiler bolt minor detonation"/>
		<mnemonic name="compiler bolt major detonation"/>
		<mnemonic name="compiler bolt major contrail"/>
		<mnemonic name="fighter projectile detonation"/>
		<mnemonic name="fighter melee detonation"/>
		<mnemonic name="hunter projectile detonation"/>
		<mnemonic name="hunter spark"/>
		<mnemonic name="minor fusion detonation"/>
		<mnemonic name="major fusion detonation"/>
		<mnemonic name="major fusion contrail"/>
		<mnemonic name="fist detonation"/>
		<mnemonic name="minor defender detonation"/>
		<mnemonic name="major defender detonation"/>
		<mnemonic name="defender spark"/>
		<mnemonic name="trooper blood splash"/>
		<mnemonic name="water lamp breaking"/>
		<mnemonic name="lava lamp breaking"/>
		<mnemonic name="sewage lamp breaking"/>
		<mnemonic name="alien lamp breaking"/>
		<mnemonic name="metallic clang"/>
		<mnemonic name="teleport object in"/>
		<mnemonic name="teleport object out"/>
		<mnemonic name="small water splash"/>
		<mnemonic name="medium water splash"/>
		<mnemonic name="large water splash"/>
		<mnemonic name="large water emergence"/>
		<mnemonic name="small lava splash"/>
		<mnemonic name="medium lava splash"/>
		<mnemonic name="large lava splash"/>
		<mnemonic name="large lava emergence"/>
		<mnemonic name="small sewage splash"/>
		<mnemonic name="medium sewage splash"/>
		<mnemonic name="large sewage splash"/>
		<mnemonic name="large sewage emergence"/>
		<mnemonic name="small goo splash"/>
		<mnemonic name="medium goo splash"/>
		<mnemonic name="large goo splash"/>
		<mnemonic name="large goo emergence"/>
		<mnemonic name="minor hummer projectile detonation"/>
		<mnemonic name="major hummer projectile detonation"/>
		<mnemonic name="durandal hummer projectile detonation"/>
		<mnemonic name="hummer spark"/>
		<mnemonic name="cyborg projectile detonation"/>
		<mnemonic name="cyborg blood splash"/>
		<mnemonic name="minor fusion dispersal"/>
		<mnemonic name="major fusion dispersal"/>
		<mnemonic name="overloaded fusion dispersal"/>
		<mnemonic name="sewage yeti blood splash"/>
		<mnemonic name="sewage yeti projectile detonation"/>
		<mnemonic name="water yeti blood splash"/>
		<mnemonic name="lava yeti blood splash"/>
		<mnemonic name="lava yeti projectile detonation"/>
		<mnemonic name="yeti melee detonation"/>
		<mnemonic name="juggernaut spark"/>
		<mnemonic name="juggernaut missile contrail"/>
		<mnemonic name="small jjaro splash"/>
		<mnemonic name="medium jjaro splash"/>
		<mnemonic name="large jjaro splash"/>
		<mnemonic name="large jjaro emergence"/>
		<mnemonic name="civilian fusion blood splash"/>
		<mnemonic name="assimilated civilian fusion blood splash"/>
      </mnemonics>
    </enum>
	<enum name="ephemera_quality">
	  <mnemonics>
		<mnemonic name="off"/>
		<mnemonic name="low"/>
		<mnemonic name="medium"/>
		<mnemonic name="high"/>
		<mnemonic name="ultra"/>
	  </mnemonics>
	</enum>
    <enum name="fade_type">
      <mnemonics>
		<mnemonic name="start cinematic fade in"/>
		<mnemonic name="cinematic fade in"/>
		<mnemonic name="long cinematic fade in"/>
		<mnemonic name="cinematic fade out"/>
		<mnemonic name="end cinematic fade out"/>
		<mnemonic name="red"/>
		<mnemonic name="big red"/>
		<mnemonic name="bonus"/>
		<mnemonic name="bright"/>
		<mnemonic name="long bright"/>
		<mnemonic name="yellow"/>
		<mnemonic name="big yellow"/>
		<mnemonic name="purple"/>
		<mnemonic name="cyan"/>
		<mnemonic name="white"/>
		<mnemonic name="big white"/>
		<mnemonic name="orange"/>
		<mnemonic name="long orange"/>
		<mnemonic name="green"/>
		<mnemonic name="long green"/>
		<mnemonic name="static"/>
		<mnemonic name="negative"/>
		<mnemonic name="big negative"/>
		<mnemonic name="flicker negative"/>
		<mnemonic name="dodge purple"/>
		<mnemonic name="burn cyan"/>
		<mnemonic name="dodge yellow"/>
		<mnemonic name="burn green"/>
		<mnemonic name="tint green"/>
		<mnemonic name="tint blue"/>
		<mnemonic name="tint orange"/>
		<mnemonic name="tint gross"/>
		<mnemonic name="tint jjaro"/>
      </mnemonics>
    </enum>
	<enum name="fog_mode">
	  <mnemonics>
		<mnemonic name="linear"/>
		<mnemonic name="exp"/>
		<mnemonic name="exp2"/>
	  </mnemonics>
	</enum>
    <enum name="game_type">
      <mnemonics>
		<mnemonic name="kill monsters"/>
		<mnemonic name="cooperative play"/>
		<mnemonic name="capture the flag"/>
		<mnemonic name="king of the hill"/>
		<mnemonic name="kill the man with the ball"/>
		<mnemonic name="defense"/>
		<mnemonic name="rugby"/>
		<mnemonic name="tag"/>
		<mnemonic name="netscript"/>
      </mnemonics>
    </enum>
	<enum name="item_kind" version="20210408">
	  <mnemonics>
		<mnemonic name="weapon"/>
		<mnemonic name="ammunition"/>
		<mnemonic name="powerup"/>
		<mnemonic name="item"/>
		<mnemonic name="weapon powerup"/>
		<mnemonic name="ball"/>
	  </mnemonics>
	</enum>
    <enum name="item_type">
      <variable name="initial_count" version="20111201">
		<description>how many items of this type are placed in the level during initial placement</description>
		<type>number</type>
      </variable>
	  <variable name="kind" access="read-only" version="20210408">
		<description>kind of item this is</description>
		<type>item_kind</type>
	  </variable>
      <variable name="maximum_count" version="20111201">
		<description>maximum number of this type of item in the level and in player inventories</description>
		<type>number</type>
      </variable>
	  <variable name="maximum_inventory" version="20210408">
		<description>maximum number of this type of item players can carry</description>
		<type>number</type>
	  </variable>
      <variable name="minimum_count" version="20111201">
		<description>minimum number of this type of item in the level and in player inventories</description>
		<type>number</type>
      </variable>
      <variable name="random_chance" version="20111201">
		<description>chance from 0 to 1.0 this item will appear in a respawn period</description>
		<type>chance</type>
      </variable>
      <variable name="random_location" version="20111201">
		<description>whether items of this type spawn in random locations</description>
		<type>boolean</type>
      </variable>
      <variable name="total_available" version="20111201">
		<description>total number of items of this type that can be spawned in this level</description>
		<type>number</type>
		<note>-1 means infinite items are available</note>
		<note>setting this to anything but -1 will only be effective if changed immediately when the script runs, before item placement is done</note>
      </variable>
      <mnemonics>
		<mnemonic name="knife"/>
		<mnemonic name="pistol"/>
		<mnemonic name="pistol ammo"/>
		<mnemonic name="fusion pistol"/>
		<mnemonic name="fusion pistol ammo"/>
		<mnemonic name="assault rifle"/>
		<mnemonic name="assault rifle ammo"/>
		<mnemonic name="assault rifle grenades"/>
		<mnemonic name="missile launcher"/>
		<mnemonic name="missile launcher ammo"/>
		<mnemonic name="invisibility"/>
		<mnemonic name="invincibility"/>
		<mnemonic name="infravision"/>
		<mnemonic name="alien weapon"/>
		<mnemonic name="alien weapon ammo"/>
		<mnemonic name="flamethrower"/>
		<mnemonic name="flamethrower ammo"/>
		<mnemonic name="extravision"/>
		<mnemonic name="oxygen"/>
		<mnemonic name="single health"/>
		<mnemonic name="double health"/>
		<mnemonic name="triple health"/>
		<mnemonic name="shotgun"/>
		<mnemonic name="shotgun ammo"/>
		<mnemonic name="key"/>
		<mnemonic name="uplink chip"/>
		<mnemonic name="light blue ball"/>
		<mnemonic name="ball"/>
		<mnemonic name="violet ball"/>
		<mnemonic name="yellow ball"/>
		<mnemonic name="brown ball"/>
		<mnemonic name="orange ball"/>
		<mnemonic name="blue ball"/>
		<mnemonic name="green ball"/>
		<mnemonic name="smg"/>
		<mnemonic name="smg ammo"/>
      </mnemonics>
    </enum>
    <enum name="light_function">
      <mnemonics>
		<mnemonic name="constant"/>
		<mnemonic name="linear"/>
		<mnemonic name="smooth"/>
		<mnemonic name="flicker"/>
      </mnemonics>
    </enum>
    <enum name="light_preset">
      <mnemonics>
		<mnemonic name="normal"/>
		<mnemonic name="strobe"/>
		<mnemonic name="media"/>
      </mnemonics>
    </enum>
    <enum name="light_state">
      <mnemonics>
		<mnemonic name="becoming active"/>
		<mnemonic name="primary active"/>
		<mnemonic name="secondary active"/>
		<mnemonic name="becoming inactive"/>
		<mnemonic name="primary inactive"/>
		<mnemonic name="secondary inactive"/>
      </mnemonics>
    </enum>
    <enum name="media_type">
      <mnemonics>
		<mnemonic name="water"/>
		<mnemonic name="lava"/>
		<mnemonic name="goo"/>
		<mnemonic name="sewage"/>
		<mnemonic name="jjaro"/>
      </mnemonics>
    </enum>
    <enum name="monster_action">
      <mnemonics>
		<mnemonic name="stationary"/>
		<mnemonic name="waiting to attack again"/>
		<mnemonic name="moving"/>
		<mnemonic name="attacking close"/>
		<mnemonic name="attacking far"/>
		<mnemonic name="being hit"/>
		<mnemonic name="dying hard"/>
		<mnemonic name="dying soft"/>
		<mnemonic name="dying flaming"/>
		<mnemonic name="teleporting"/>
		<mnemonic name="teleporting in"/>
		<mnemonic name="teleporting out"/>
      </mnemonics>
    </enum>
    <enum name="monster_class">
      <mnemonics>
		<mnemonic name="player"/>
		<mnemonic name="bob"/>
		<mnemonic name="madd"/>
		<mnemonic name="possessed drone"/>
		<mnemonic name="defender"/>
		<mnemonic name="fighter"/>
		<mnemonic name="trooper"/>
		<mnemonic name="hunter"/>
		<mnemonic name="enforcer"/>
		<mnemonic name="juggernaut"/>
		<mnemonic name="drone"/>
		<mnemonic name="compiler"/>
		<mnemonic name="cyborg"/>
		<mnemonic name="explodabob"/>
		<mnemonic name="tick"/>
		<mnemonic name="yeti"/>
      </mnemonics>
    </enum>
    <enum name="monster_mode">
      <mnemonics>
		<mnemonic name="locked"/>
		<mnemonic name="losing lock"/>
		<mnemonic name="lost lock"/>
		<mnemonic name="unlocked"/>
		<mnemonic name="running"/>
      </mnemonics>
    </enum>
    <enum name="monster_type">
	  <variable name="alien" version="20220115">
		<description>moves slower on slower levels, etc.</description>
		<type>boolean</type>
	  </variable>
      <variable name="attacks_immediately" version="20120128">
		<description>monster will try an attack immediately</description>
		<type>boolean</type>
      </variable>
	  <variable name="berserker" version="20220115">
		<description>below 1/4 vitality, this monster goes berserk</description>
		<type>boolean</type>
	  </variable>
	  <variable name="can_die_in_flames" version="20220115">
		<description>uses humanoid dying shape</description>
		<type>boolean</type>
	  </variable>
	  <variable name="can_teleport_under_media" version="20220115">
		<type>boolean</type>
	  </variable>
	  <variable name="cannot_attack" version="20220115">
		<description>monster has no weapons and cannot attack (runs constantly to safety)</description>
		<type>boolean</type>
	  </variable>
      <variable name="cannot_be_dropped" version="20120128">
		<description>monster cannot be skipped during placement</description>
		<type>boolean</type>
      </variable>
	  <variable name="cannot_fire_backward" version="20220115">
		<description>monster can’t turn more than 135 degrees</description>
		<type>boolean</type>
	  </variable>
	  <variable name="chooses_weapons_randomly" version="20220115">
		<type>boolean</type>
	  </variable>
      <variable name="class">
		<description>class of monster type</description>
		<type>monster_class</type>
      </variable>
	  <variable name="collection" access="read-only" version="20210408">
		<description>collection of monster type</description>
		<type>collection</type>
	  </variable>
	  <variable name="clut_index" access="read-only" version="20210408">
		<description>color table of monster type</description>
		<type>number</type>
	  </variable>
      <function-variable name="enemies" classname="monster_type_enemies">
		<description>whether monster class is an enemy</description>
		<argument name="monster_class"><type>monster_class</type></argument>
		<type>boolean</type>
      </function-variable>
	  <variable name="enlarged" version="20220115">
		<description>monster is 1.25 times normal height</description>
		<type>boolean</type>
	  </variable>
	  <variable name="fires_symmetrically" version="20220115">
		<description>fires at +/- dy, simultaneously</description>
		<type>boolean</type>
	  </variable>
	  <variable name="flies" version="20220115">
		<type>boolean</type>
	  </variable>
	  <variable name="floats" version="20220115">
		<description>exclusive from flies; forces the monster to take delta-h gradually</description>
		<type>boolean</type>
	  </variable>
      <function-variable name="friends" classname="monster_type_friends">
		<description>whether monster class is a friend</description>
		<argument name="monster_class"><type>monster_class</type></argument>
		<type>boolean</type>
      </function-variable>
	  <variable name="has_delayed_hard_death" version="20220115">
		<description>always dies soft, then switches to hard</description>
		<type>boolean</type>
	  </variable>
	  <variable name="has_nuclear_hard_death" version="20220115">
		<description>player’s screen whites out and slowly recovers</description>
		<type>boolean</type>
	  </variable>
      <variable name="impact_effect" access="read-only">
		<description>type of effect generated when monster gets hit by a bleeding projectile</description>
		<type>effect_type</type>
      </variable>
      <variable name="height" access="read-only">
		<description>height of monster</description>
		<type>WU</type>
      </variable>
	  <function-variable name="immunities" classname="monster_type_immunities">
		<description>whether monster type is immune to damage type</description>
		<argument name="damage_type"><type>damage_type</type></argument>
		<type>boolean</type>
	  </function-variable>
	  <variable name="impact_effect" access="read-only">
		<type>effect</type>
	  </variable>
      <variable name="initial_count" version="20111201">
		<description>how many monsters of this type are placed in the level during initial placement</description>
		<type>number</type>
      </variable>
	  <variable name="invisible" version="20220115">
		<description>this monster uses _xfer_invisibility</description>
		<type>boolean</type>
	  </variable>
      <variable name="item">
		<description>type of item the monster drops when it dies</description>
		<type>item_type</type>
      </variable>
	  <variable name="kamikaze" version="20220115">
		<description>monster does shrapnel damage and will suicide if close enough to target</description>
		<type>boolean</type>
	  </variable>
      <variable name="major" version="20120128">
		<description>monster is major</description>
		<type>boolean</type>
      </variable>
      <variable name="maximum_count" version="20111201">
		<description>maximum number of this type of monster in the level</description>
		<type>number</type>
      </variable>
      <variable name="melee_impact_effect" access="read-only">
		<description>type of effect generated when monster gets hit by a melee projectile</description>
		<type>effect_type</type>
      </variable>
      <variable name="minimum_count" version="20111201">
		<description>minimum number of this type of monster in the level</description>
		<type>number</type>
      </variable>
      <variable name="minor" version="20120128">
		<description>monster is minor</description>
		<type>boolean</type>
      </variable>
	  <variable name="not_afraid_of_goo" version="20220115">
		<type>boolean</type>
	  </variable>
	  <variable name="not_afraid_of_lava" version="20220115">
		<type>boolean</type>
	  </variable>
	  <variable name="not_afraid_of_sewage" version="20220115">
		<type>boolean</type>
	  </variable>
	  <variable name="not_afraid_of_water" version="20220115">
		<type>boolean</type>
	  </variable>
	  <variable name="omniscient" version="20220115">
		<description>ignores line-of-sight during find_closest_appropriate_target()</description>
		<type>boolean</type>
	  </variable>
      <variable name="radius" access="read-only">
		<description>radius of monster</description>
		<type>WU</type>
      </variable>
      <variable name="random_chance" version="20111201">
		<description>chance from 0 to 1.0 this monster will appear in a respawn period</description>
		<type>chance</type>
      </variable>
      <variable name="random_location" version="20111201">
		<description>whether monsters of this type spawn in random locations</description>
		<type>boolean</type>
      </variable>
	  <variable name="subtly_invisible" version="20220115">
		<description>this monster uses _xfer_subtle_invisibility</description>
		<type>boolean</type>
	  </variable>
	  <variable name="tiny" version="20220115">
		<description>0.25-size normal height</description>
		<type>boolean</type>
	  </variable>
      <variable name="total_available" version="20111201">
		<description>total number of monsters of this type that can be spawned in this level</description>
		<type>number</type>
		<note>-1 means infinite monsters are available</note>
		<note>setting this to anything but -1 will only be effective if changed immediately when the script runs, before monster placement is done</note>
      </variable>
	  <variable name="uses_sniper_ledges" version="20220115">
		<description>sit on ledges and hurl shit at the player (ranged attack monsters only</description>
		<type>boolean</type>
	  </variable>
	  <variable name="vitality" version="20220115" access="read-only">
		<description>monster’s initial vitality</description>
		<type>number</type>
	  </variable>
      <function-variable name="weaknesses" classname="monster_type_weaknesses">
		<description>whether monster type has a weakness to damage type</description>
		<argument name="damage type"><type>damage_type</type></argument>
		<type>boolean</type>
      </function-variable>
      <variable name="waits_with_clear_shot" version="20120128">
		<description>monster will sit and fire if he has a clear shot</description>
		<type>boolean</type>
      </variable>
      <mnemonics>
		<mnemonic name="player"/>
		<mnemonic name="minor tick"/>
		<mnemonic name="major tick"/>
		<mnemonic name="kamikaze tick"/>
		<mnemonic name="minor compiler"/>
		<mnemonic name="major compiler"/>
		<mnemonic name="minor invisible compiler"/>
		<mnemonic name="major invisible compiler"/>
		<mnemonic name="minor fighter"/>
		<mnemonic name="major fighter"/>
		<mnemonic name="minor projectile fighter"/>
		<mnemonic name="major projectile fighter"/>
		<mnemonic name="green bob"/>
		<mnemonic name="blue bob"/>
		<mnemonic name="security bob"/>
		<mnemonic name="explodabob"/>
		<mnemonic name="minor drone"/>
		<mnemonic name="major drone"/>
		<mnemonic name="big minor drone"/>
		<mnemonic name="big major drone"/>
		<mnemonic name="possessed drone"/>
		<mnemonic name="minor cyborg"/>
		<mnemonic name="major cyborg"/>
		<mnemonic name="minor flame cyborg"/>
		<mnemonic name="major flame cyborg"/>
		<mnemonic name="minor enforcer"/>
		<mnemonic name="major enforcer"/>
		<mnemonic name="minor hunter"/>
		<mnemonic name="major hunter"/>
		<mnemonic name="minor trooper"/>
		<mnemonic name="major trooper"/>
		<mnemonic name="mother of all cyborgs"/>
		<mnemonic name="mother of all hunters"/>
		<mnemonic name="sewage yeti"/>
		<mnemonic name="water yeti"/>
		<mnemonic name="lava yeti"/>
		<mnemonic name="minor defender"/>
		<mnemonic name="major defender"/>
		<mnemonic name="minor juggernaut"/>
		<mnemonic name="major juggernaut"/>
		<mnemonic name="tiny pfhor"/>
		<mnemonic name="tiny bob"/>
		<mnemonic name="tiny yeti"/>
		<mnemonic name="green vacbob"/>
		<mnemonic name="blue vacbob"/>
		<mnemonic name="security vacbob"/>
		<mnemonic name="explodavacbob"/>
      </mnemonics>
    </enum>
    <enum name="overlay_color">
      <mnemonics>
		<mnemonic name="green"/>
		<mnemonic name="white"/>
		<mnemonic name="red"/>
		<mnemonic name="dark green"/>
		<mnemonic name="cyan"/>
		<mnemonic name="yellow"/>
		<mnemonic name="dark red"/>
		<mnemonic name="blue"/>
      </mnemonics>
    </enum>
    <enum name="platform_type">
      <mnemonics>
		<mnemonic name="spht door"/>
		<mnemonic name="spht split door"/>
		<mnemonic name="locked spht door"/>
		<mnemonic name="spht platform"/>
		<mnemonic name="noisy spht platform"/>
		<mnemonic name="heavy spht door"/>
		<mnemonic name="pfhor door"/>
		<mnemonic name="heavy spht platform"/>
		<mnemonic name="pfhor platform"/>
      </mnemonics>
    </enum>
    <enum name="player_color">
      <mnemonics>
		<mnemonic name="slate"/>
		<mnemonic name="red"/>
		<mnemonic name="violet"/>
		<mnemonic name="yellow"/>
		<mnemonic name="white"/>
		<mnemonic name="orange"/>
		<mnemonic name="blue"/>
		<mnemonic name="green"/>
      </mnemonics>
    </enum>
    <enum name="polygon_type">
      <mnemonics>
		<mnemonic name="normal"/>
		<mnemonic name="item impassable"/>
		<mnemonic name="monster impassable"/>
		<mnemonic name="hill"/>
		<mnemonic name="base"/>
		<mnemonic name="platform"/>
		<mnemonic name="light on trigger"/>
		<mnemonic name="platform on trigger"/>
		<mnemonic name="light off trigger"/>
		<mnemonic name="platform off trigger"/>
		<mnemonic name="teleporter"/>
		<mnemonic name="zone border"/>
		<mnemonic name="goal"/>
		<mnemonic name="visible monster trigger"/>
		<mnemonic name="invisible monster trigger"/>
		<mnemonic name="dual monster trigger"/>
		<mnemonic name="item trigger"/>
		<mnemonic name="must be explored"/>
		<mnemonic name="automatic exit"/>
		<mnemonic name="minor ouch"/>
		<mnemonic name="major ouch"/>
		<mnemonic name="glue"/>
		<mnemonic name="glue trigger"/>
		<mnemonic name="superglue"/>
      </mnemonics>
    </enum>
    <enum name="projectile_type">
      <mnemonics>
		<mnemonic name="missile"/>
		<mnemonic name="grenade"/>
		<mnemonic name="pistol bullet"/>
		<mnemonic name="rifle bullet"/>
		<mnemonic name="shotgun bullet"/>
		<mnemonic name="staff"/>
		<mnemonic name="staff bolt"/>
		<mnemonic name="flamethrower burst"/>
		<mnemonic name="compiler bolt minor"/>
		<mnemonic name="compiler bolt major"/>
		<mnemonic name="alien weapon"/>
		<mnemonic name="fusion bolt minor"/>
		<mnemonic name="fusion bolt major"/>
		<mnemonic name="hunter"/>
		<mnemonic name="fist"/>
		<mnemonic name="armageddon sphere"/>
		<mnemonic name="armageddon electricity"/>
		<mnemonic name="juggernaut rocket"/>
		<mnemonic name="trooper bullet"/>
		<mnemonic name="trooper grenade"/>
		<mnemonic name="minor defender"/>
		<mnemonic name="major defender"/>
		<mnemonic name="juggernaut missile"/>
		<mnemonic name="minor energy drain"/>
		<mnemonic name="major energy drain"/>
		<mnemonic name="oxygen drain"/>
		<mnemonic name="minor hummer"/>
		<mnemonic name="major hummer"/>
		<mnemonic name="durandal hummer"/>
		<mnemonic name="minor cyborg ball"/>
		<mnemonic name="major cyborg ball"/>
		<mnemonic name="ball"/>
		<mnemonic name="minor fusion dispersal"/>
		<mnemonic name="major fusion dispersal"/>
		<mnemonic name="overloaded fusion dispersal"/>
		<mnemonic name="yeti"/>
		<mnemonic name="sewage yeti"/>
		<mnemonic name="lava yeti"/>
		<mnemonic name="smg bullet"/>
      </mnemonics>
    </enum>
    <enum name="scenery_type">
      <mnemonics>
		<mnemonic name="light dirt"/>
		<mnemonic name="dark dirt"/>
		<mnemonic name="lava bones"/>
		<mnemonic name="lava bone"/>
		<mnemonic name="ribs"/>
		<mnemonic name="skull"/>
		<mnemonic name="hanging light 1"/>
		<mnemonic name="hanging light 2"/>
		<mnemonic name="small cylinder"/>
		<mnemonic name="large cylinder"/>
		<mnemonic name="block 1"/>
		<mnemonic name="block 2"/>
		<mnemonic name="block 3"/>

		<mnemonic name="pistol clip"/>
		<mnemonic name="water short light"/>
		<mnemonic name="water long light"/>
		<mnemonic name="siren"/>
		<mnemonic name="rocks"/>
		<mnemonic name="blood drops"/>
		<mnemonic name="water thing"/>
		<mnemonic name="gun"/>
		<mnemonic name="bob remains"/>
		<mnemonic name="puddles"/>
		<mnemonic name="big puddles"/>
		<mnemonic name="security monitor"/>
		<mnemonic name="water alien supply can"/>
		<mnemonic name="machine"/>
		<mnemonic name="staff"/>
		
		<mnemonic name="sewage short light"/>
		<mnemonic name="sewage long light"/>
		<mnemonic name="junk"/>
		<mnemonic name="antenna"/>
		<mnemonic name="big antenna"/>
		<mnemonic name="sewage alien supply can"/>
		<mnemonic name="sewage bones"/>
		<mnemonic name="sewage big bones"/>
		<mnemonic name="pfhor pieces"/>
		<mnemonic name="bob pieces"/>
		<mnemonic name="bob blood"/>
		
		<mnemonic name="alien short light"/>
		<mnemonic name="alien long light"/>
		<mnemonic name="alien ceiling rod light"/>
		<mnemonic name="bulbous yellow alien object"/>
		<mnemonic name="square gray organic object"/>
		<mnemonic name="pfhor skeleton"/>
		<mnemonic name="pfhor mask"/>
		<mnemonic name="green stuff"/>
		<mnemonic name="hunter shield"/>
		<mnemonic name="alien bones"/>
		<mnemonic name="alien sludge"/>

		<mnemonic name="jjaro short light"/>
		<mnemonic name="jjaro long light"/>
		<mnemonic name="weird rod"/>
		<mnemonic name="pfhor ship"/>
		<mnemonic name="sun"/>
		<mnemonic name="large glass container"/>
		<mnemonic name="nub 1"/>
		<mnemonic name="nub 2"/>
		<mnemonic name="lh'owon"/>
		<mnemonic name="floor whip antenna"/>
		<mnemonic name="ceiling whip antenna"/>
      </mnemonics>
    </enum>
    <enum name="side_type">
      <mnemonics>
		<mnemonic name="full"/>
		<mnemonic name="high"/>
		<mnemonic name="low"/>
		<mnemonic name="split"/>
      </mnemonics>
    </enum>
    <enum name="sound">
      <mnemonics>
		<mnemonic name="startup"/>
		<mnemonic name="teleport in"/>
		<mnemonic name="teleport out"/>
		<mnemonic name="crushed"/>
		<mnemonic name="nuclear hard death"/>
		<mnemonic name="absorbed"/>
		<mnemonic name="breathing"/>
		<mnemonic name="oxygen warning"/>
		<mnemonic name="suffocation"/>
		<mnemonic name="energy refuel"/>
		<mnemonic name="oxygen refuel"/>
		<mnemonic name="cant toggle switch"/>
		<mnemonic name="switch on"/>
		<mnemonic name="switch off"/>
		<mnemonic name="puzzle switch"/>
		<mnemonic name="chip insertion"/>
		<mnemonic name="pattern buffer"/>
		<mnemonic name="destroy control panel"/>
		<mnemonic name="adjust volume"/>
		<mnemonic name="got powerup"/>
		<mnemonic name="get item"/>
		<mnemonic name="bullet ricochet"/>
		<mnemonic name="metallic ricochet"/>
		<mnemonic name="empty gun"/>
		<mnemonic name="spht door opening"/>
		<mnemonic name="spht door closing"/>
		<mnemonic name="spht door obstructed"/>
		<mnemonic name="spht platform starting"/>
		<mnemonic name="spht platform stopping"/>
		<mnemonic name="loon"/>
		<mnemonic name="smg firing"/>
		<mnemonic name="smg reloading"/>
		<mnemonic name="heavy spht platform starting"/>
		<mnemonic name="heavy spht platform stopping"/>
		<mnemonic name="fist hitting"/>
		<mnemonic name="pistol firing"/>
		<mnemonic name="pistol reloading"/>
		<mnemonic name="assault rifle firing"/>
		<mnemonic name="grenade launcher firing"/>
		<mnemonic name="grenade expolding"/>
		<mnemonic name="grenade flyby"/>
		<mnemonic name="fusion firing"/>
		<mnemonic name="fusion exploding"/>
		<mnemonic name="fusion flyby"/>
		<mnemonic name="fusion charging"/>
		<mnemonic name="rocket exploding"/>
		<mnemonic name="rocket flyby"/>
		<mnemonic name="rocket firing"/>
		<mnemonic name="flamethrower"/>
		<mnemonic name="body falling"/>
		<mnemonic name="body exploding"/>
		<mnemonic name="bullet hit flesh"/>
		<mnemonic name="fighter activate"/>
		<mnemonic name="fighter wail"/>
		<mnemonic name="fighter scream"/>
		<mnemonic name="fighter chatter"/>
		<mnemonic name="fighter attack"/>
		<mnemonic name="fighter projectile hit"/>
		<mnemonic name="fighter projectile flyby"/>
		<mnemonic name="spht attack"/>
		<mnemonic name="spht death"/>
		<mnemonic name="spht hit"/>
		<mnemonic name="spht projectile flyby"/>
		<mnemonic name="spht projectile hit"/>
		<mnemonic name="cyborg moving"/>
		<mnemonic name="cyborg attack"/>
		<mnemonic name="cyborg hit"/>
		<mnemonic name="cyborg death"/>
		<mnemonic name="cyborg projectile bounce"/>
		<mnemonic name="cyborg projectile hit"/>
		<mnemonic name="cyborg projectile flyby"/>
		<mnemonic name="drone activate"/>
		<mnemonic name="drone start attack"/>
		<mnemonic name="drone attack"/>
		<mnemonic name="drone dying"/>
		<mnemonic name="drone death"/>
		<mnemonic name="drone projectile hit"/>
		<mnemonic name="drone projectile flyby"/>
		<mnemonic name="bob wail"/>
		<mnemonic name="bob scream"/>
		<mnemonic name="bob hit"/>
		<mnemonic name="bob chatter"/>
		<mnemonic name="assimilated bob chatter"/>
		<mnemonic name="bob trash talk"/>
		<mnemonic name="bob apology"/>
		<mnemonic name="bob activation"/>
		<mnemonic name="bob clear"/>
		<mnemonic name="bob angry"/>
		<mnemonic name="bob secure"/>
		<mnemonic name="bob kill the player"/>
		<mnemonic name="water"/>
		<mnemonic name="sewage"/>
		<mnemonic name="lava"/>
		<mnemonic name="goo"/>
		<mnemonic name="underwater"/>
		<mnemonic name="wind"/>
		<mnemonic name="waterfall"/>
		<mnemonic name="siren"/>
		<mnemonic name="fan"/>
		<mnemonic name="spht door"/>
		<mnemonic name="spht platform"/>
		<mnemonic name="alien harmonics"/>
		<mnemonic name="heavy spht platform"/>
		<mnemonic name="light machinery"/>
		<mnemonic name="heavy machinery"/>
		<mnemonic name="transformer"/>
		<mnemonic name="sparking transformer"/>
		<mnemonic name="water drip"/>
		<mnemonic name="walking in water"/>
		<mnemonic name="exiting water"/>
		<mnemonic name="entering water"/>
		<mnemonic name="small water splash"/>
		<mnemonic name="medium water splash"/>
		<mnemonic name="large water splash"/>
		<mnemonic name="walking in lava"/>
		<mnemonic name="entering lava"/>
		<mnemonic name="exiting lava"/>
		<mnemonic name="small lava splash"/>
		<mnemonic name="medium lava splash"/>
		<mnemonic name="large lava splash"/>
		<mnemonic name="walking in sewage"/>
		<mnemonic name="exiting sewage"/>
		<mnemonic name="entering sewage"/>
		<mnemonic name="small sewage splash"/>
		<mnemonic name="medium sewage splash"/>
		<mnemonic name="large sewage splash"/>
		<mnemonic name="walking in goo"/>
		<mnemonic name="exiting goo"/>
		<mnemonic name="entering goo"/>
		<mnemonic name="small goo splash"/>
		<mnemonic name="medium goo splash"/>
		<mnemonic name="large goo splash"/>
		<mnemonic name="major fusion firing"/>
		<mnemonic name="major fusion charged"/>
		<mnemonic name="assault rifle reloading"/>
		<mnemonic name="assault rifle shell casings"/>
		<mnemonic name="shotgun firing"/>
		<mnemonic name="shotgun reloading"/>
		<mnemonic name="ball bounce"/>
		<mnemonic name="you are it"/>
		<mnemonic name="got ball"/>
		<mnemonic name="computer login"/>
		<mnemonic name="computer logout"/>
		<mnemonic name="computer page"/>
		<mnemonic name="heavy spht door"/>
		<mnemonic name="heavy spht door opening"/>
		<mnemonic name="heavy spht door closing"/>
		<mnemonic name="heavy spht door open"/>
		<mnemonic name="heavy spht door closed"/>
		<mnemonic name="heavy spht door obstructed"/>
		<mnemonic name="hunter activate"/>
		<mnemonic name="hunter attack"/>
		<mnemonic name="hunter dying"/>
		<mnemonic name="hunter landing"/>
		<mnemonic name="hunter exploding"/>
		<mnemonic name="hunter projectile hit"/>
		<mnemonic name="hunter projectile flyby"/>
		<mnemonic name="enforcer activate"/>
		<mnemonic name="enforcer attack"/>
		<mnemonic name="enforcer projectile hit"/>
		<mnemonic name="enforcer projectile flyby"/>
		<mnemonic name="flickta melee attack"/>
		<mnemonic name="flickta melee hit"/>
		<mnemonic name="flickta projectile attack"/>
		<mnemonic name="flickta projectile sewage hit"/>
		<mnemonic name="flickta projectile sewage flyby"/>
		<mnemonic name="flickta projectile lava hit"/>
		<mnemonic name="flickta projectile lava flyby"/>
		<mnemonic name="flickta dying"/>
		<mnemonic name="machine binder"/>
		<mnemonic name="machine bookpress"/>
		<mnemonic name="machine puncher"/>
		<mnemonic name="electric hum"/>
		<mnemonic name="alarm"/>
		<mnemonic name="night wind"/>
		<mnemonic name="surface explosion"/>
		<mnemonic name="underground explosion"/>
		<mnemonic name="sphtkr attack"/>
		<mnemonic name="sphtkr projectile hit"/>
		<mnemonic name="sphtkr projectile flyby"/>
		<mnemonic name="sphtkr hit"/>
		<mnemonic name="sphtkr exploding"/>
		<mnemonic name="tick chatter"/>
		<mnemonic name="tick falling"/>
		<mnemonic name="tick flapping"/>
		<mnemonic name="tick exploding"/>
		<mnemonic name="ceiling lamp exploding"/>
		<mnemonic name="pfhor platform starting"/>
		<mnemonic name="pfhor platform stopping"/>
		<mnemonic name="pfhor platform"/>
		<mnemonic name="pfhor door opening"/>
		<mnemonic name="pfhor door closing"/>
		<mnemonic name="pfhor door obstructed"/>
		<mnemonic name="pfhor door"/>
		<mnemonic name="pfhor switch off"/>
		<mnemonic name="pfhor switch on"/>
		<mnemonic name="juggernaut firing"/>
		<mnemonic name="juggernaut warning"/>
		<mnemonic name="juggernaut exploding"/>
		<mnemonic name="juggernaut start attack"/>
		<mnemonic name="enforcer exploding"/>
		<mnemonic name="alien noise 1"/>
		<mnemonic name="alien noise 2"/>
		<mnemonic name="vacbob wail"/>
		<mnemonic name="vacbob scream"/>
		<mnemonic name="vacbob hit"/>
		<mnemonic name="vacbob chatter"/>
		<mnemonic name="assimilated vacbob chatter"/>
		<mnemonic name="vacbob trash talk"/>
		<mnemonic name="vacbob apology"/>
		<mnemonic name="vacbob activation"/>
		<mnemonic name="vacbob clear"/>
		<mnemonic name="vacbob angry"/>
		<mnemonic name="vacbob secure"/>
		<mnemonic name="vacbob kill the player"/>
      </mnemonics>
    </enum>
    <enum name="texture_type">
      <mnemonics>
        <mnemonic name="wall"/>
        <mnemonic name="landscape"/>
        <mnemonic name="sprite"/>
        <mnemonic name="weapon in hand"/>
        <mnemonic name="interface"/>
      </mnemonics>
    </enum>
    <enum name="transfer_mode">
      <mnemonics>
		<mnemonic name="normal"/>
		<mnemonic name="pulsate"/>
		<mnemonic name="wobble"/>
		<mnemonic name="fast wobble"/>
		<mnemonic name="static"/>
		<mnemonic name="landscape"/>
		<mnemonic name="horizontal slide"/>
		<mnemonic name="fast horizontal slide"/>
		<mnemonic name="vertical slide"/>
		<mnemonic name="fast vertical slide"/>
		<mnemonic name="wander"/>
		<mnemonic name="fast wander"/>
		<mnemonic name="reverse horizontal slide" version="20231125"/>
		<mnemonic name="reverse fast horizontal slide" version="20231125"/>
		<mnemonic name="reverse vertical slide" version="20231125"/>
		<mnemonic name="reverse fast vertical slide" version="20231125"/>
		<mnemonic name="2x" version="20231125"/>
		<mnemonic name="4x" version="20231125"/>
      </mnemonics>
    </enum>
    <enum name="weapon_type">
      <mnemonics>
		<mnemonic name="fist"/>
		<mnemonic name="pistol"/>
		<mnemonic name="fusion pistol"/>
		<mnemonic name="assault rifle"/>
		<mnemonic name="missile launcher"/>
		<mnemonic name="flamethrower"/>
		<mnemonic name="alien weapon"/>
		<mnemonic name="shotgun"/>
		<mnemonic name="ball"/>
		<mnemonic name="smg"/>
      </mnemonics>
    </enum>
    <enum-accessor name="AmbientSounds" contains="ambient_sound" nice-name="Ambient Sounds"/>
    <enum-accessor name="CompletionStates" contains="completion_state" nice-name="Completion States"/>
    <enum-accessor name="Collections" contains="collection" nice-name="Collections"/>
    <enum-accessor name="ControlPanelClasses" contains="control_panel_class" nice-name="Control Panel Classes"/>
    <enum-accessor name="ControlPanelTypes" contains="control_panel_type" nice-name="Control Panel Types"/>
    <enum-accessor name="DamageTypes" contains="damage_type" nice-name="Damage"/>
    <enum-accessor name="DifficultyTypes" contains="difficulty_type" nice-name="Difficulty"/>
    <enum-accessor name="EffectTypes" contains="effect_type" nice-name="Effects"/>
	<enum-accessor name="EphemeraQualities" contains="ephemera_quality" nice-name="Ephemera Quality"/>
    <enum-accessor name="FadeTypes" contains="fade_type" nice-name="Faders"/>
	<enum-accessor name="FogModes" contains="fog_mode" nice-name="Fog Modes"/>
    <enum-accessor name="GameTypes" contains="game_type" nice-name="Game Types"/>
    <enum-accessor name="ItemKinds" contains="item_kind" nice-name="Item Kinds"/>
    <enum-accessor name="ItemTypes" contains="item_type" nice-name="Item Types"/>
    <enum-accessor name="MediaTypes" contains="media_type" nice-name="Media"/>
    <enum-accessor name="LightFunctions" contains="light_function" nice-name="Light Functions"/>
    <enum-accessor name="LightPresets" contains="light_preset" nice-name="Light Presets"/>
    <enum-accessor name="LightStates" contains="light_state" nice-name="Light States"/>
    <enum-accessor name="MonsterActions" contains="monster_action" nice-name="Monster Actions"/>
    <enum-accessor name="MonsterClasses" contains="monster_class" nice-name="Monster Classes"/>
    <enum-accessor name="MonsterModes" contains="monster_mode" nice-name="Monster Modes"/>
    <enum-accessor name="MonsterTypes" contains="monster_type" nice-name="Monsters"/>
    <enum-accessor name="OverlayColors" contains="overlay_color" nice-name="Overlay Colors"/>
    <enum-accessor name="PlatformTypes" contains="platform_type" nice-name="Platform Types"/>
    <enum-accessor name="PlayerColors" contains="player_color" nice-name="Player and Team Colors"/>
    <enum-accessor name="PolygonTypes" contains="polygon_type" nice-name="Polygons"/>
    <enum-accessor name="ProjectileTypes" contains="projectile_type" nice-name="Projectiles"/>
    <enum-accessor name="SceneryTypes" contains="scenery_type" nice-name="Scenery"/>
    <enum-accessor name="ScoringModes" contains="scoring_mode" nice-name="Scoring Modes"/>
    <enum-accessor name="SideTypes" contains="side_type" nice-name="Side Types"/>
    <enum-accessor name="Sounds" contains="sound" nice-name="Sounds"/>
    <enum-accessor name="TextureTypes" contains="texture_type" nice-name="Texture Types"/>
    <enum-accessor name="TransferModes" contains="transfer_mode" nice-name="Transfer Modes"/>
    <enum-accessor name="WeaponTypes" contains="weapon_type" nice-name="Weapons"/>
  </tables>
  <types id="types">
    <description>The string mnemonics listed below can be used for assignment and as arguments to functions. Additionally, Aleph One’s Lua interpreter has been modified so that equality comparisons between userdata types and strings are possible.</description>
    <description>For example, this script would move all players on the blue team to the red team:
<span class="pre">for p in Players() do
  if p.team == "blue" then
    p.team = "red"
  end
end</span>
And this one would damage all major compilers with 10 points of fusion damage:
<span class="pre">for m in Monsters() do
  if m.type == "major compiler" then
    m:damage(10, "fusion")
  end
end</span>
Each type has a read-only .index field, which represents the game’s internal index:
<span class="pre">&gt; =ItemTypes["pistol"].index
1
</span>
Each type also has a .mnemonic field, which is handy for finding the mnemonic of a given type:
<span class="pre">&gt; =MonsterTypes["major compiler"].class.mnemonic
compiler
</span>
You can even use the mnemonic field to customize the mnemonics for your scenario. Note that you can only have one string mnemonic per type index:
<span class="pre">&gt; WeaponTypes["fist"].mnemonic = "puncher"
&gt; =WeaponTypes["puncher"].index
0
&gt; =WeaponTypes["fist"]
nil
</span>
If you do this, you should customize them all at the beginning of the script. Changing mnemonics mid-game will confuse anyone who tries to read your script, and probably yourself as well!
</description>
  </types>
  <section name="Example Icon" id="example_icon">
    <description>
      <pre>
--[[
This is  an example  of an  icon  in  the format  used by  Aleph One’s  overlay
functions.
The first characters  are a digit string  describing the number of  colors. (in
this example, it’s 7.
The first character that  is not a digit is ignored,  as are all the characters
following it  that are the same  character. (i.e. I  could use a q instead of a
newline here.
Then,  for  every color,  it reads  a character,  followed by  a six-digit  hex
string,  which is the  HTML-style color corresponding  to that character in the
image.  After reading this string,  it ignores the next character,  whatever it
is.
Once it has  read every color,  it reads all the following characters,  and for
every character it reads for which a color has defined, it puts that color into
the icon as the next pixel. Other characters are ignored. (see below.)
Icons are always 16x16.
]]

[[
7
 0000FF
#000000
.FFFFFF
$7FAE20
%EBD52A
,45983C
*5B4714
*************# The fact
*************# that it
*$$$#*********# ignores
$$$$$#********# characters
$$$$$#$$******# that
$$##$##$$*****# are
$$$$##.#$$#**# not colors
$%%$$#.,#$#**# can be
%%%%%%##,#$$# exploited to interesting
%%%%%%%##$$# effect by a sufficiently
#%%%%%%%$$$$# resourceful and obnoxious
*##%%%%%%$$$$###
#**#%%#%%%###**#
*#*##%%#%%$$$$# person
**#  #%%##%$$# such as
**#   #%%%#%$# myself :)
Additionally, once it has read 256 valid characters, it ignores the rest of the
string.
]]
      </pre>
    </description>
  </section>
</document>
